require_relative './readable_grammar.rb'
require_relative './cpp_tokens.rb'

# todo
    # fix sizeof, alignas, decltype, and similar
    # fix initializer list "functions" e.g. `int a{5};` 
    # fix the ... inside of macros
    # have all patterns with keywords be dynamically generated

cpp_grammar = Grammar.new(
    name:"C++",
    scope_name: "source.cpp",
    version: "https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master/generate.rb",
    information_for_contributors: [
        "This code was auto generated by a much-more-readble ruby file: https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master/generate.rb",
        "It is a lot easier to modify the ruby file and have it generate the rest of the code",
        "Also the ruby source is very open to merge requests, so please make one if something could be improved",
        "This file essentially an updated/improved fork of the atom syntax https://github.com/atom/language-c/blob/master/grammars/c%2B%2B.cson",
    ],
)

#
#
# Numbers
#
#
    #
    # misc
    #
        number_seperator_pattern = newPattern(
            repository_name: 'literal_numeric_seperator',
            match: lookBehindToAvoid(/'/).then(/'/).lookAheadToAvoid(/'/),
            tag_as:"punctuation.separator.constant.numeric"
        )
        hex_digits = newPattern(
                match: /[0-9a-fA-F]/.zeroOrMoreOf(/[0-9a-fA-F]/.or(number_seperator_pattern)),
                tag_as: "constant.numeric.hexadecimal",
                includes: [ number_seperator_pattern ]
            )
        decimal_digits = newPattern(
                match: /[0-9]/.zeroOrMoreOf(/[0-9]/.or(number_seperator_pattern)),
                tag_as: "constant.numeric.decimal",
                includes: [ number_seperator_pattern ]
            )
        # see https://en.cppreference.com/w/cpp/language/floating_literal
        hex_exponent = newPattern(
                match: /[pP]/,
                tag_as: "keyword.other.unit.exponent.hexadecimal",
            ).maybe(
                match: /\+/,
                tag_as: "keyword.operator.plus.exponent.hexadecimal",
            ).maybe(
                match: /\-/,
                tag_as: "keyword.operator.minus.exponent.hexadecimal",
            ).then(
                match: decimal_digits.without_numbered_capture_groups,
                tag_as: "constant.numeric.exponent.hexadecimal",
                includes: [ number_seperator_pattern ]
            )
        decimal_exponent = newPattern(
                match: /[eE]/,
                tag_as: "keyword.other.unit.exponent.decimal",
            ).maybe(
                match: /\+/,
                tag_as: "keyword.operator.plus.exponent.decimal",
            ).maybe(
                match: /\-/,
                tag_as: "keyword.operator.minus.exponent.decimal",
            ).then(
                match: decimal_digits.without_numbered_capture_groups,
                tag_as: "constant.numeric.exponent.decimal",
                includes: [ number_seperator_pattern ]
            )
    #
    # Number Literal
    #
    number_literal = newPattern(
        repository_name: 'number_literal',
        match: lookBehindToAvoid(/\w/).then(
                # Floating point
                # see https://en.cppreference.com/w/cpp/language/floating_literal
                newPattern(
                    floating_literal = newPattern(
                        # Hex
                        newPattern(
                            hex_literal_float = newPattern(
                                match: /0[xX]/,
                                tag_as: "keyword.other.unit.hexadecimal",
                            ).maybe(
                                hex_digits
                            ).then(
                                # lookBehind/Ahead because there needs to be a hex digit on at least one side 
                                match: lookBehindFor(/[0-9a-fA-F]/).then(/\./).or(/\./.lookAheadFor(/[0-9a-fA-F]/)),
                                tag_as: "constant.numeric.hexadecimal",
                            ).maybe(
                                hex_digits
                            ).maybe(
                                hex_exponent
                            )
                        # Decimal
                        ).or(
                            decimal_literal_float = maybe(
                                decimal_digits
                            ).then(
                                # lookBehind/Ahead because there needs to be a decimal digit on at least one side 
                                match: lookBehindFor(/[0-9]/).then(/\./).or(/\./.lookAheadFor(/[0-9]/)),
                                tag_as: "constant.numeric.decimal.point",
                            ).maybe(
                                decimal_digits
                            ).maybe(
                                decimal_exponent
                            )
                        )
                    # Floating point suffix
                    ).maybe(
                        literal_float_suffix = newPattern(
                            match: /[lLfF]/.lookAheadToAvoid(/\w/),
                            tag_as: "keyword.other.unit.suffix.floating-point"
                        )
                    )
                # Integer
                # see https://en.cppreference.com/w/cpp/language/integer_literal
                ).or(
                     integer_literal = newPattern(
                        # Binary
                        newPattern(
                            binary_literal_integer = newPattern(
                                match: /0[bB]/,
                                tag_as: "keyword.other.unit.binary"
                            ).then(
                                match: oneOrMoreOf(/[01]/.or(number_seperator_pattern)),
                                tag_as: "constant.numeric.binary",
                                includes: [ number_seperator_pattern ]
                            )
                        # Octal
                        ).or(
                            octal_literal_integer = newPattern(
                                match: /0/,
                                tag_as: "keyword.other.unit.octal"
                            ).then(
                                match: oneOrMoreOf(/[0-7]/.or(number_seperator_pattern)),
                                tag_as: "constant.numeric.octal",
                                includes: [ number_seperator_pattern ]
                            )
                        # Hex
                        ).or(
                            hex_literal_integer = newPattern(
                                match: /0[xX]/,
                                tag_as: "keyword.other.unit.hexadecimal",
                            ).then(
                                hex_digits
                            ).maybe(
                                hex_exponent
                            )
                        # Decimal
                        ).or(
                            decimal_literal_integer = newPattern(
                                decimal_digits
                            ).maybe(
                                decimal_exponent
                            )
                        )
                    # integer suffix
                    ).maybe(
                        literal_integer_suffix = newPattern(
                            match: /LL[uU]/.or(/ll[uU]/).or(/[uU]LL/).or(/[uU]ll/).or(/ll/).or(/LL/).or(/[uUlL]/).lookAheadToAvoid(/\w/),
                            tag_as: "keyword.other.unit.suffix.integer"
                        )
                    )
                )
            # user defined endings
            ).then(
                match: /\w*/,
                tag_as: "keyword.other.unit.user-defined"
            )
    )
    
#
# Variable
#
    # todo: make a better name for this function
    variableBounds = ->(regex_pattern) do
        lookBehindToAvoid(@standard_character).then(regex_pattern).lookAheadToAvoid(@standard_character)
    end
    variable_name_without_bounds = /[a-zA-Z_]#{@standard_character.without_default_mode_modifiers}*/
    # word bounds are inefficient, but they are accurate
    variable_name = variableBounds[variable_name_without_bounds]

#
# Constants
#
    language_constants = newPattern(
        repository_name: 'constants',
        match: variableBounds[@cpp_tokens.that(:isLiteral)],
        tag_as: "constant.language"
    )

#
# Types
#
    look_behind_for_type = lookBehindFor(/\w |\*\/|[&*>\]\)]/).maybe(@spaces)
    # why is posix reserved types not in "storage_types"? I don't know, if you can get it in there and everything still works it would be appreciated
    posix_reserved_types = newPattern(
        match: variableBounds[  /[a-zA-Z_]/.zeroOrMoreOf(@standard_character).then(/_t/)  ],
        name: "support.type.posix-reserved"
    )
    storage_types = newPattern(
        repository_name: 'storage_types',
        includes: [
            
            primitive_types = newPattern(
                match: variableBounds[ @cpp_tokens.that(:isPrimitive) ],
                tag_as: "storage.type.primitive"
            ),
            
            non_primitive_types = newPattern(
                match: variableBounds[@cpp_tokens.that(not(:isPrimitive), :isType)],
                tag_as: "storage.type"
            ),
            
            # FIXME, these should be changed to each have their own matcher, and struct should be handled the similar to 'class'
            other_types = newPattern(
                match: variableBounds[ /(asm|__asm__|enum|union|struct)/ ],
                tag_as: "storage.type.$1"
            )
        ]
    )

#
# Keywords and Keyword-ish things
#
    functional_specifiers_pre_parameters = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isFunctionSpecifier) ],
        tag_as: "storage.modifier.specificer.functional.pre-parameters.$1"
    )
    qualifiers_and_specifiers_post_parameters = newPattern(
        match: variableBounds[ @cpp_tokens.that(:canAppearAfterParametersBeforeBody) ].lookAheadFor(/\s*/.then(/\{/.or(/;/).or(/[\n\r]/))),
        tag_as: "storage.modifier.specifier.functional.post-parameters.$1"
    )
    storage_specifiers = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isStorageSpecifier) ],
        tag_as: "storage.modifier.specifier.$1"
    )
    access_control_keywords = newPattern(
        match: lookBehindToAvoid(@standard_character).then(@cpp_tokens.that(:isAccessSpecifier)).then(/ *:/),
        tag_as: "storage.type.modifier.access.control.$1"
    )
    exception_keywords = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isExceptionRelated) ],
        tag_as: "keyword.control.exception.$1"
    )
    other_keywords = newPattern(
        match: variableBounds[ /(using|typedef)/ ],
        tag_as: "keyword.other.$1"
    )
    the_this_keyword = newPattern(
        match: variableBounds[ /this/ ],
        tag_as: "variable.language.this"
    )
    # TODO: enhance this to include <>'s
    type_casting_operators = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isTypeCastingOperator) ],
        tag_as: "keyword.operator.cast.$1"
    )
    memory_operators = newPattern(
        repository_name: 'memory_operators',
        tag_as: "keyword.operator.memory",
        match: lookBehindToAvoid(
                @standard_character
            ).then(
                newPattern(
                    newPattern(
                        match: /delete/,
                        tag_as: "keyword.operator.memory.delete.array"
                    ).maybe(@spaces).then(
                        match: /\[\]/,
                        tag_as: "keyword.operator.memory.delete.array.bracket"
                    )
                ).or(
                    match: /delete/,
                    tag_as: "keyword.operator.memory.delete"
                ).or(
                    match: /new/,
                    tag_as: "keyword.operator.memory.new"
                )
            ).lookAheadToAvoid(@standard_character)
    )
    control_flow_keywords = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isControlFlow) ],
        tag_as: "keyword.control.$1"
    )
#
# Operators
#
    normal_word_operators = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isOperator, :isWord, not(:isTypeCastingOperator), not(:isControlFlow)) ],
        tag_as: "keyword.operator.$1",
    )

#
# Templates
#
    characters_in_template_call = /[\s<>,\w]/
    template_call = newPattern(
        repository_name: 'template_call_innards',
        tag_as: 'meta.template.call',
        match: /</.zeroOrMoreOf(characters_in_template_call).then(/>/).maybe(@spaces),
        includes: [
            :storage_types,
            :constants,
            :scope_resolution,
            newPattern(
                match: variable_name,
                tag_as: 'storage.type.user-defined'
            ),
            :operators,
            :number_literal,
            :strings,
            newPattern(
                match: /,/,
                tag_as: "punctuation.separator.comma.template.argument"
            )
        ]
    )
    template_definition = Range.new(
        repository_name: 'template_definition',
        tag_as: 'meta.template.definition',
        start_pattern: lookBehindToAvoid(@standard_character).then(
                match: /template/,
                tag_as: "storage.type.template"
            ).maybe(@spaces).then(
                match: /</,
                tag_as: "punctuation.section.angle-brackets.start.template.definition"
            ),
        end_pattern: newPattern(
                match: />/,
                tag_as: "punctuation.section.angle-brackets.end.template.definition"
            ),
        includes: [
            :scope_resolution,
            :template_definition_argument,
            :template_call_innards,
        ]
    )
    template_definition_argument = newPattern(
        repository_name: 'template_definition_argument',
        match: maybe(
                @spaces
            # case 1: only one word
            ).then(
                match: variable_name_without_bounds,
                tag_as: "storage.type.template.argument.$1",
            # case 2: normal situation (ex: "typename T")
            ).or(
                newPattern( 
                    match: oneOrMoreOf(variable_name_without_bounds.then(@spaces)),
                    tag_as: "storage.type.template.argument.$2",
                ).then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.type.template",
                )
            # case 3: ellipses (ex: "typename... Args")
            ).or(
                newPattern(
                    match: variable_name_without_bounds,
                    tag_as: "storage.type.template",
                ).maybe(@spaces).then(
                    match: /\.\.\./,
                    tag_as: "keyword.operator.ellipsis.template.definition",
                ).maybe(@spaces).then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.type.template"
                )
            # case 4: defaulted assignment (ex: "int N = 0")
            ).or(
                newPattern(
                    match: zeroOrMoreOf(variable_name_without_bounds.then(@spaces)),
                    tag_as: "storage.type.template",
                ).then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.type.template"
                ).maybe(@spaces).then(
                    match: /[=]/,
                    tag_as: "keyword.operator.assignment"
                # FIXME, this last group needs to be updated
                ).maybe(@spaces).then(
                    match: /\w+/,
                    tag_as: "constant.other"
                )
            # ending
            ).maybe(@spaces).then(
                newPattern(
                    match: /,/,
                    tag_as: "punctuation.separator.comma.template.argument",
                ).or(
                    lookAheadFor(/>/)
                )
            )
    )

#
# Scope resolution
#
    one_scope_resolution = variable_name_without_bounds.maybe(@spaces).maybe(template_call.without_numbered_capture_groups).then(/::/)
    preceding_scopes = newPattern(
        match: zeroOrMoreOf(one_scope_resolution).maybe(@spaces),
        includes: [ :scope_resolution ]
    )
    scope_resolution = newPattern(
        repository_name: 'scope_resolution',
        tag_as: "meta.scope-resolution",
        match: preceding_scopes.then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.namespace.scope-resolution"
            ).maybe(@spaces).maybe(
                match: template_call.without_numbered_capture_groups,
                includes: [ :template_call_innards ]
            ).then(
                match: /::/,
                tag_as: "punctuation.separator.namespace.access"
            )
        )

#
# Probably a parameter
#
    array_brackets = /\[\]/.maybe(@spaces)
    comma_or_closing_paraenthese = /,/.or(/\)/)
    stuff_after_a_parameter = maybe(@spaces).lookAheadFor(maybe(array_brackets).then(comma_or_closing_paraenthese))
    probably_a_parameter = newPattern(
        repository_name: 'probably_a_parameter',
        match: newPattern(
            match: variable_name_without_bounds.maybe(@spaces).lookAheadFor("="),
            tag_as: "variable.parameter.probably.defaulted"
        ).or(
            match: look_behind_for_type.then(variable_name_without_bounds).then(stuff_after_a_parameter),
            tag_as: "variable.parameter.probably"
        )
    )

#
# Operator overload
#
    # symbols can have spaces
    operator_symbols = maybe(@spaces).then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isSymbol))
    # words must have spaces, the variable_name_without_bounds is for implicit overloads
    operator_wordish = @spaces.then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isWordish).or(zeroOrMoreOf(one_scope_resolution).then(variable_name_without_bounds).maybe(@spaces).maybe(/&/)))
    after_operator_keyword = operator_symbols.or(operator_wordish)
    operator_overload = Range.new(
        repository_name: 'operator_overload',
        tag_as: "meta.function.definition.parameters.operator-overload",
        start_pattern: newPattern(
                match: /operator/,
                tag_as: "keyword.other.operator.overload",
            ).then(
                match: after_operator_keyword,
                tag_as: "entity.name.operator.overloadee",
                includes: [:scope_resolution]
            ).maybe(@spaces).then(
                match: /\(/,
                tag_as: "punctuation.section.parameters.begin.bracket.round"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.parameters.end.bracket.round"
            ),
        includes: [:probably_a_parameter, :'function-innards-c' ]
    )

#
# Access . .* -> ->*
#
    dot_operator = /\./.or(/\.\*/)
    arrow_operator = /->/.or(/->\*/)
    member_operator = newPattern(
            match: dot_operator,
            tag_as: "punctuation.separator.dot-access"
        ).or(
            match: arrow_operator,
            tag_as: "punctuation.separator.pointer-access"
        )
    subsequent_object_with_operator = variable_name_without_bounds.maybe(@spaces).then(member_operator.without_numbered_capture_groups).maybe(@spaces)
    # TODO: the member_access and method_access can probably be simplified considerably
    # TODO: member_access and method_access might also need additional matching to handle scope resolutions
    member_access = newPattern(
        repository_name: 'member_access',
        tag_as: "variable.other.object.access",
        match: newPattern(
            match: variable_name_without_bounds.or(lookBehindFor(/\]|\)/)).maybe(@spaces),
            tag_as: "variable.other.object",
        ).then(
            member_operator
        ).then(
            match: zeroOrMoreOf(subsequent_object_with_operator),
            includes: [ :member_access, :method_access ]
        ).then(
            match: @word_boundary.lookAheadToAvoid(@cpp_tokens.that(:isType)).then(variable_name_without_bounds).then(@word_boundary).lookAheadToAvoid(/\(/),
            tag_as: "variable.other.member"
        )
    )
    method_access = Range.new(
        repository_name: 'method_access',
        tag_as: "meta.function-call.member",
        start_pattern: newPattern(
                match: variable_name_without_bounds.or(lookBehindFor(/\]|\)/)).maybe(@spaces),
                tag_as: "variable.other.object",
            ).then(
                member_operator
            ).then(
                match: zeroOrMoreOf(subsequent_object_with_operator),
                includes: [ :member_access, :method_access ]
            ).maybe(@spaces).then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.function.member"
            ).then(
                match: /\(/,
                tag_as: "punctuation.section.arguments.begin.bracket.round.function.member"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.arguments.end.bracket.round.function.member"
            ),
        includes: ["#function-call-innards-c"],
    )

#
# Functions
#
    cant_be_a_function_name = @cpp_tokens.that(:isWord,  not(:isPreprocessorDirective), not(:isValidFunctionName))
    avoid_invalid_function_names = lookBehindToAvoid(@standard_character).lookAheadToAvoid(maybe(@spaces).then(cant_be_a_function_name).maybe(@spaces).then(/\(/))
    look_ahead_for_function_name = lookAheadFor(variable_name_without_bounds.maybe(@spaces).then(/\(/))
    function_definition = Range.new(
        tag_as: "meta.function.definition",
        start_pattern: avoid_invalid_function_names.then(look_ahead_for_function_name),
        end_pattern: lookBehindFor(/\)/),
        includes: [ "#function-innards-c" ]
    )
    # a full match example of function call would be: aNameSpace::subClass<TemplateArg>FunctionName<5>(
    function_call = Range.new(
        start_pattern: avoid_invalid_function_names.then(
                preceding_scopes
            ).then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.function.call"
            ).maybe(@spaces).maybe(
                # TODO: repository_name's need to say as a pseudo element in 'group_attributes' so that when they're converted they don't copy and paste everything
                # once that^ is done, this can be replaced with just 'template_call'
                match: template_call.without_numbered_capture_groups,
                includes: [ :template_call_innards ]
            ).then(
                match: /\(/,
                tag_as: "punctuation.section.arguments.begin.bracket.round"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.arguments.end.bracket.round"
            ),
        includes: [ "#function-call-innards-c" ]
    )

#
# Namespace
#
    # see https://en.cppreference.com/w/cpp/language/namespace
    using_namespace = Range.new(
        tag_as: "meta.using-namespace-declaration",
        start_pattern: lookBehindToAvoid(@standard_character).then(
                match: /using/,
                tag_as: "keyword.other.using.directive",
            ).then(@spaces).then(
                match: /namespace/,
                tag_as: "keyword.other.namespace.directive storage.type.namespace.directive"
            ).then(@spaces).maybe(
                preceding_scopes
            ).then(
                match: variable_name,
                tag_as: "entity.name.namespace"
            ).lookAheadFor(
                /;|\n/
            ),
        end_pattern: newPattern(
                match: /;/,
                tag_as: "punctuation.terminator.statement"
            ),
        )
    # TODO: add support for namespace name = qualified-namespace ;
    namespace_definition = Range.new(
        tag_as: "meta.namespace-block",
        start_pattern: lookBehindToAvoid(@standard_character).then(
                match: /namespace/,
                tag_as: "keyword.other.namespace.definition storage.type.namespace.definition"
            ).then(@spaces).then(
                # Named namespace (with possible scope )
                preceding_scopes
            ).maybe(@spaces).then(
                newPattern(
                    match: variable_name,
                    tag_as: "entity.name.namespace",
                # anonymous namespaces
                ).or(
                    lookAheadFor(/\{/)
                )
            ),
        end_pattern: lookBehindFor(/\}/).or(lookAheadFor(/;|,|\(|\)|>|\[|\]|=/)),
        includes: [
            Range.new(
                start_pattern: newPattern(
                        match: /\{/,
                        tag_as: "punctuation.definition.scope"
                    ),
                end_pattern: newPattern(
                        match: /\}/,
                        tag_as: "punctuation.definition.scope"
                    ),
                includes: [:special_block, :constructor, "$base" ]
                
            ),
            "$base"
        ]
    )

#
# preprocessor
#
    # not sure if this pattern is actually accurate (it was the one provided by atom/c.tmLanguage)
    preprocessor_name_no_bounds = /[a-zA-Z_$][\w$]*/
    preprocessor_function_name = preprocessor_name_no_bounds.lookAheadFor(maybe(@spaces).then(/\(/))
    macro_argument = newPattern(
        match: /##/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
        name: "variable.other.macro.argument"
    )

#
# Support
#
    # TODO: currently this is used, ideally it will be built up over time and then be included
    # it will be for things such as cout, cin, vector, string, map, etc

cpp_grammar.initalContextIncludes(
    :special_block,
    macro_argument,
    :strings,
    functional_specifiers_pre_parameters,
    qualifiers_and_specifiers_post_parameters,
    storage_specifiers,
    access_control_keywords,
    exception_keywords,
    other_keywords,
    :memory_operators,
    the_this_keyword,
    language_constants,
    template_definition,
    type_casting_operators,
    scope_resolution,
    {
        match: -/\b(decltype|wchar_t|char16_t|char32_t)\b/,
        name: "storage.type"
    },
    {
        match: -/\b(constexpr|export|mutable|typename|thread_local)\b/,
        name: "storage.modifier"
    },
    {
        name: "meta.function.destructor",
        begin: "(?x)\n(?:\n  ^ |                  # beginning of line\n  (?:(?<!else|new|=))  # or word + space before name\n)\n((?:[A-Za-z_][A-Za-z0-9_]*::)*+~[A-Za-z_][A-Za-z0-9_]*) # actual name\n\\s*(\\()              # opening bracket",
        beginCaptures: {
            "1" => {
                name: "entity.name.function.destructor"
            },
            "2" => {
                name: "punctuation.definition.parameters.begin.destructor"
            }
        },
        end: -/\)/,
        endCaptures: {
            "0" => {
                name: "punctuation.definition.parameters.end.destructor"
            }
        },
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    {
        name: "meta.function.destructor.prototype",
        begin: "(?x)\n(?:\n  ^ |                  # beginning of line\n  (?:(?<!else|new|=))  # or word + space before name\n)\n((?:[A-Za-z_][A-Za-z0-9_]*::)*+~[A-Za-z_][A-Za-z0-9_]*) # actual name\n\\s*(\\()              # opening bracket",
        beginCaptures: {
            "1" => {
                name: "entity.name.function"
            },
            "2" => {
                name: "punctuation.definition.parameters.begin"
            }
        },
        end: -/\)/,
        endCaptures: {
            "0" => {
                name: "punctuation.definition.parameters.end"
            }
        },
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    #
    # C patterns
    #
    "#preprocessor-rule-enabled",
    "#preprocessor-rule-disabled",
    "#preprocessor-rule-conditional",
    "#comments-c",
    control_flow_keywords,
    storage_types,
    {
        match: "\\b(const|extern|register|restrict|static|volatile|inline)\\b",
        name: "storage.modifier"
    },
    operator_overload,
    number_literal,
    :strings_c,
    {
        name: "meta.preprocessor.macro",
        begin: "(?x)\n^\\s* ((\\#)\\s*define) \\s+\t# define\n((?<id>#{-preprocessor_name_no_bounds}))\t  # macro name\n(?:\n  (\\()\n\t(\n\t  \\s* \\g<id> \\s*\t\t # first argument\n\t  ((,) \\s* \\g<id> \\s*)*  # additional arguments\n\t  (?:\\.\\.\\.)?\t\t\t# varargs ellipsis?\n\t)\n  (\\))\n)?",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.define"
            },
            "2" => {
                name: "punctuation.definition.directive"
            },
            "3" => {
                name: "entity.name.function.preprocessor"
            },
            "5" => {
                name: "punctuation.definition.parameters.begin"
            },
            "6" => {
                name: "variable.parameter.preprocessor"
            },
            "8" => {
                name: "punctuation.separator.parameters"
            },
            "9" => {
                name: "punctuation.definition.parameters.end"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        patterns: [
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    {
        name: "meta.preprocessor.diagnostic",
        begin: "^\\s*((#)\\s*(error|warning))\\b\\s*",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.diagnostic.$3"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?<!\\\\)(?=\\n)",
        patterns: [
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "'",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "[^'\"]",
                end: "(?<!\\\\)(?=\\s*\\n)",
                name: "string.unquoted.single",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    },
                    {
                        include: "#comments-c"
                    }
                ]
            }
        ]
    },
    {
        name: "meta.preprocessor.include",
        begin: "^\\s*((#)\\s*(include(?:_next)?|import))\\b\\s*",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.$3"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        patterns: [
            {
                include: "#line_continuation_character"
            },
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double.include"
            },
            {
                begin: "<",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: ">",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.other.lt-gt.include"
            }
        ]
    },
    "#pragma-mark",
    {
        name: "meta.preprocessor",
        begin: "^\\s*((#)\\s*line)\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.line"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        patterns: [
            {
                include: "#strings_c"
            },
            {
                include: "#number_literal"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    {
        name: "meta.preprocessor",
        begin: "^\\s*(?:((#)\\s*undef))\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.undef"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        patterns: [
            {
                match: -preprocessor_name_no_bounds,
                name: "entity.name.function.preprocessor"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    {
        name: "meta.preprocessor.pragma",
        begin: "^\\s*(?:((#)\\s*pragma))\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.pragma"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        patterns: [
            {
                include: "#strings_c"
            },
            {
                match: "[a-zA-Z_$][\\w\\-$]*",
                name: "entity.other.attribute-name.pragma.preprocessor"
            },
            {
                include: "#number_literal"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    :operators,
    {
        match: "\\b(u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|div_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\\b",
        name: "support.type.sys-types"
    },
    {
        match: "\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b",
        name: "support.type.pthread"
    },
    {
        match: "(?x) \\b\n(int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t\n|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t\n|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t\n|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t\n|uintmax_t|uintmax_t)\n\\b",
        name: "support.type.stdint"
    },
    posix_reserved_types,
    "#block-c",
    "#parens-c",
    function_definition,
    "#line_continuation_character",
    {
        name: "meta.bracket.square.access",
        begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))?(\\[)(?!\\])",
        beginCaptures: {
            "1" => {
                name: "variable.other.object"
            },
            "2" => {
                name: "punctuation.definition.begin.bracket.square"
            }
        },
        end: "\\]",
        endCaptures: {
            "0" => {
                name: "punctuation.definition.end.bracket.square"
            }
        },
        patterns: [
            {
                include: "#function-call-innards-c"
            }
        ]
    },
    {
        name: "storage.modifier.array.bracket.square",
        match: -/#{lookBehindToAvoid(/delete/)}\\[\\s*\\]/
    },
    {
        match: ";",
        name: "punctuation.terminator.statement"
    },
    {
        match: ",",
        name: "punctuation.separator.delimiter"
    }
)
cpp_grammar.addToRepository({
    "angle_brackets" => {
        begin: "<",
        end: ">",
        name: "meta.angle-brackets",
        patterns: [
            {
                include: "#angle_brackets"
            },
            {
                include: "$base"
            }
        ]
    },
    "block" => {
        begin: "\\{",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.block.begin.bracket.curly"
            }
        },
        end: "\\}",
        endCaptures: {
            "0" => {
                name: "punctuation.section.block.end.bracket.curly"
            }
        },
        name: "meta.block",
        patterns: [
            {
                captures: {
                    "1" => {
                        name: "support.function.any-method"
                    },
                    "2" => {
                        name: "punctuation.definition.parameters"
                    }
                },
                match: "(?x)\n(\n  (?!while|for|do|if|else|switch|catch|return)\n  (?:\\b[A-Za-z_][A-Za-z0-9_]*+\\b|::)*+ # actual name\n)\n\\s*(\\() # opening bracket",
                name: "meta.function-call"
            },
            {
                include: "$base"
            }
        ]
    },
    "constructor" => {
        patterns: [
            {
                begin: "(?x)\n(?:^\\s*)  # beginning of line\n((?!while|for|do|if|else|switch|catch)[A-Za-z_][A-Za-z0-9_:]*) # actual name\n\\s*(\\()  # opening bracket",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function.constructor"
                    },
                    "2" => {
                        name: "punctuation.definition.parameters.begin.constructor"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.parameters.end.constructor"
                    }
                },
                name: "meta.function.constructor",
                patterns: [
                    {
                        include: "#probably_a_parameter"
                    },
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                begin: "(?x)\n(:)\n(\n  (?=\n    \\s*[A-Za-z_][A-Za-z0-9_:]* # actual name\n    \\s* (\\() # opening bracket\n  )\n)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.definition.initializer-list.parameters"
                    }
                },
                end: "(?=\\{)",
                name: "meta.function.constructor.initializer-list",
                patterns: [
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "special_block" => {
        patterns: [
            using_namespace.to_tag,
            namespace_definition.to_tag,
            {
                begin: "\\b(?:(class)|(struct))\\b\\s*([_A-Za-z][_A-Za-z0-9]*\\b)?+(\\s*:\\s*(public|protected|private)\\s*([_A-Za-z][_A-Za-z0-9]*\\b)((\\s*,\\s*(public|protected|private)\\s*[_A-Za-z][_A-Za-z0-9]*\\b)*))?",
                beginCaptures: {
                    "1" => {
                        name: "storage.type.class"
                    },
                    "2" => {
                        name: "storage.type.struct"
                    },
                    "3" => {
                        name: "entity.name.type"
                    },
                    "5" => {
                        name: "storage.type.modifier.access"
                    },
                    "6" => {
                        name: "entity.name.type.inherited"
                    },
                    "7" => {
                        patterns: [
                            {
                                match: "(public|protected|private)",
                                name: "storage.type.modifier.access"
                            },
                            {
                                match: "[_A-Za-z][_A-Za-z0-9]*",
                                name: "entity.name.type.inherited"
                            }
                        ]
                    }
                },
                end: "(?<=\\})|(;)|(?=(\\(|\\)|>|\\[|\\]|=))",
                endCaptures: {
                    "1" => {
                        name: "punctuation.terminator.statement",
                    },
                },
                name: "meta.class-struct-block",
                patterns: [
                    {
                        include: "#angle_brackets"
                    },
                    {
                        begin: "\\{",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.section.block.begin.bracket.curly"
                            }
                        },
                        end: "(\\})(\\s*\\n)?",
                        endCaptures: {
                            "1" => {
                                name: "punctuation.section.block.end.bracket.curly"
                            },
                            "2" => {
                                name: "invalid.illegal.you-forgot-semicolon"
                            }
                        },
                        patterns: [
                            {
                                include: "#special_block"
                            },
                            {
                                include: "#constructor"
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            },
            {
                begin: "\\b(extern)(?=\\s*\")",
                beginCaptures: {
                    "1" => {
                        name: "storage.modifier"
                    }
                },
                end: "(?<=\\})|(?=\\w)|(?=\\s*#\\s*endif\\b)",
                name: "meta.extern-block",
                patterns: [
                    {
                        begin: "\\{",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.section.block.begin.bracket.curly"
                            }
                        },
                        end: "\\}|(?=\\s*#\\s*endif\\b)",
                        endCaptures: {
                            "0" => {
                                name: "punctuation.section.block.end.bracket.curly"
                            }
                        },
                        patterns: [
                            {
                                include: "#special_block"
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    # TODO: "strings" is included and it is different from "strings_c", but its not used anywhere. Figure out whats going on here
    "strings" => {
        patterns: [
            {
                begin: "(u|u8|U|L)?\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    },
                    "1" => {
                        name: "meta.encoding"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        match: "\\\\u\\h{4}|\\\\U\\h{8}",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\['\"?\\\\abfnrtv]",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\[0-7]{1,3}",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\x\\h+",
                        name: "constant.character.escape"
                    },
                    {
                        include: "#string_placeholder-c"
                    }
                ]
            },
            {
                begin: "(u|u8|U|L)?R\"(?:([^ ()\\\\\\t]{0,16})|([^ ()\\\\\\t]*))\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    },
                    "1" => {
                        name: "meta.encoding"
                    },
                    "3" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                end: "\\)\\2(\\3)\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    },
                    "1" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                name: "string.quoted.double.raw"
            }
        ]
    },
    "block-c" => {
        patterns: [
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                name: "meta.block",
                patterns: [
                    {
                        include: "#block_innards-c"
                    }
                ]
            }
        ]
    },
    "block_innards-c" => {
        patterns: [
            {
                include: "#preprocessor-rule-enabled-block"
            },
            {
                include: "#preprocessor-rule-disabled-block"
            },
            {
                include: "#preprocessor-rule-conditional-block"
            },
            {
                include: "#method_access"
            },
            {
                include: "#member_access"
            },
            {
                include: "#c_function_call"
            },
            {
                name: "meta.initialization",
                begin: "(?x)\n(?:\n  (?:\n\t(?=\\s)(?<!else|new|return)\n\t(?<=\\w) \\s+(and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)  # or word + space before name\n  )\n)\n(\n  (?:[A-Za-z_][A-Za-z0-9_]*+ | :: )++   # actual name\n  |\n  (?:(?<=operator) (?:[-*&<>=+!]+ | \\(\\) | \\[\\]))\n)\n\\s*(\\() # opening bracket",
                beginCaptures: {
                    "1" => {
                        name: "variable.other"
                    },
                    "2" => {
                        name: "punctuation.section.parens.begin.bracket.round.initialization"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round.initialization"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                patterns: [
                    {
                        include: "#block_innards-c"
                    }
                ]
            },
            {
                include: "#parens-block-c"
            },
            {
                include: "$base"
            }
        ]
    },
    "c_function_call" => {
        begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(?=\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*#{-maybe(template_call.without_numbered_capture_groups)}\\(  # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(\n)",
        end: "(?<=\\))(?!\\w)",
        name: "meta.function-call",
        patterns: [
            {
                include: "#function-call-innards-c"
            }
        ]
    },
    "comments-c" => {
        patterns: [
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.block"
                    }
                },
                match: "^/\\* =(\\s*.*?)\\s*= \\*/$\\n?",
                name: "comment.block"
            },
            {
                begin: "/\\*",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.begin"
                    }
                },
                end: "\\*/",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.end"
                    }
                },
                name: "comment.block"
            },
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.line"
                    }
                },
                match: "^// =(\\s*.*?)\\s*=\\s*$\\n?",
                name: "comment.line.banner"
            },
            {
                begin: "(^[ \\t]+)?(?=//)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.whitespace.comment.leading"
                    }
                },
                end: "(?!\\G)",
                patterns: [
                    {
                        begin: "//",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.definition.comment"
                            }
                        },
                        end: "(?=\\n)",
                        name: "comment.line.double-slash",
                        patterns: [
                            {
                                include: "#line_continuation_character"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "disabled" => {
        begin: "^\\s*#\\s*if(n?def)?\\b.*$",
        end: "^\\s*#\\s*endif\\b",
        patterns: [
            {
                include: "#disabled"
            },
            {
                include: "#pragma-mark"
            }
        ]
    },
    "line_continuation_character" => {
        patterns: [
            {
                match: "(\\\\)\\n",
                captures: {
                    "1" => {
                        name: "constant.character.escape.line-continuation"
                    }
                }
            }
        ]
    },
    "parens-c" => {
        name: "punctuation.section.parens-c\b",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    "parens-block-c" => {
        name: "meta.block.parens",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "#block_innards-c"
            },
            {
                match: -lookBehindToAvoid(/:/).then(/:/).lookAheadToAvoid(/:/),
                name: "punctuation.range-based"
            }
        ]
    },
    "pragma-mark" => {
        captures: {
            "1" => {
                name: "meta.preprocessor.pragma"
            },
            "2" => {
                name: "keyword.control.directive.pragma.pragma-mark"
            },
            "3" => {
                name: "punctuation.definition.directive"
            },
            "4" => {
                name: "entity.name.tag.pragma-mark"
            }
        },
        match: "^\\s*(((#)\\s*pragma\\s+mark)\\s+(.*))",
        name: "meta.section"
    },
    "operators" => {
        patterns: [
            {
                include: "#method_access",
            },
            {
                include: "#member_access",
            },
            normal_word_operators.to_tag,
            {
                match: "--",
                name: "keyword.operator.decrement"
            },
            {
                match: "\\+\\+",
                name: "keyword.operator.increment"
            },
            {
                match: "%=|\\+=|-=|\\*=|(?<!\\()/=",
                name: "keyword.operator.assignment.compound"
            },
            {
                match: "&=|\\^=|<<=|>>=|\\|=",
                name: "keyword.operator.assignment.compound.bitwise"
            },
            {
                match: "<<|>>",
                name: "keyword.operator.bitwise.shift"
            },
            {
                match: "!=|<=|>=|==|<|>",
                name: "keyword.operator.comparison"
            },
            {
                match: "&&|!|\\|\\|",
                name: "keyword.operator.logical"
            },
            {
                match: "&|\\||\\^|~",
                name: "keyword.operator"
            },
            {
                match: "=",
                name: "keyword.operator.assignment"
            },
            {
                match: "%|\\*|/|-|\\+",
                name: "keyword.operator"
            },
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                applyEndPatternLast: true,
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#method_access"
                    },
                    {
                        include: "#member_access"
                    },
                    {
                        include: "#c_function_call"
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "strings_c" => {
        patterns: [
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#string_placeholder-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: lookBehindToAvoid(/[\da-fA-F]/).then(/'/),
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            }
        ]
    },
    "string_escaped_char-c" => {
        patterns: [
            {
                match: "(?x)\\\\ (\n\\\\\t\t\t |\n[abefnprtv'\"?]   |\n[0-3]\\d{,2}\t |\n[4-7]\\d?\t\t|\nx[a-fA-F0-9]{,2} |\nu[a-fA-F0-9]{,4} |\nU[a-fA-F0-9]{,8} )",
                name: "constant.character.escape"
            },
            {
                match: "\\\\.",
                name: "invalid.illegal.unknown-escape"
            }
        ]
    },
    "string_placeholder-c" => {
        patterns: [
            {
                match: "(?x) %\n(\\d+\\$)?\t\t\t\t\t\t   # field (argument #)\n[#0\\- +']*\t\t\t\t\t\t  # flags\n[,;:_]?\t\t\t\t\t\t\t  # separator character (AltiVec)\n((-?\\d+)|\\*(-?\\d+\\$)?)?\t\t  # minimum field width\n(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?\t# precision\n(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n[diouxXDOUeEfFgGaACcSspn%]\t\t   # conversion type",
                name: "constant.other.placeholder"
            },
            # I don't think these are actual escapes, and they incorrectly mark valid strings
            # It might be related to printf and format from C (which is low priority for C++)
            # {
            #     match: "(%)(?!\"\\s*(PRI|SCN))",
            #     captures: {
            #         "1" => {
            #             name: "constant.other.placeholder"
            #         }
            #     }
            # }
        ]
    },
    "vararg_ellipses-c" => {
        match: "(?<!\\.)\\.\\.\\.(?!\\.)",
        name: "punctuation.vararg-ellipses"
    },
    "preprocessor-rule-conditional" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            },
            {
                match: "^\\s*#\\s*(else|elif|endif)\\b",
                captures: {
                    "0" => {
                        name: "invalid.illegal.stray-$1"
                    }
                }
            }
        ]
    },
    "preprocessor-rule-conditional-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif-block"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else-block"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#block_innards-c"
                    }
                ]
            },
            {
                match: "^\\s*#\\s*(else|elif|endif)\\b",
                captures: {
                    "0" => {
                        name: "invalid.illegal.stray-$1"
                    }
                }
            }
        ]
    },
    "preprocessor-rule-conditional-line" => {
        patterns: [
            {
                match: "(?:\\bdefined\\b\\s*$)|(?:\\bdefined\\b(?=\\s*\\(*\\s*(?:(?!defined\\b)[a-zA-Z_$][\\w$]*\\b)\\s*\\)*\\s*(?:\\n|//|/\\*|\\?|\\:|&&|\\|\\||\\\\\\s*\\n)))",
                name: "keyword.control.directive.conditional"
            },
            {
                match: "\\bdefined\\b",
                name: "invalid.illegal.macro-name"
            },
            {
                include: "#comments-c"
            },
            {
                include: "#strings_c"
            },
            {
                include: "#number_literal"
            },
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#operators"
            },
            {
                include: "#constants"
            },
            {
                match: -preprocessor_name_no_bounds,
                name: "entity.name.function.preprocessor"
            },
            {
                include: "#line_continuation_character"
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)|(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                        patterns: [
                            {
                                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                                name: "meta.preprocessor",
                                patterns: [
                                    {
                                        include: "#preprocessor-rule-conditional-line"
                                    }
                                ]
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif-block"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else-block"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                        patterns: [
                            {
                                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                                name: "meta.preprocessor",
                                patterns: [
                                    {
                                        include: "#preprocessor-rule-conditional-line"
                                    }
                                ]
                            },
                            {
                                include: "#block_innards-c"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled-elif" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                "contentName" => "comment.block.preprocessor.elif-branch",
                patterns: [
                    {
                        include: "#disabled"
                    },
                    {
                        include: "#pragma-mark"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    },
                    "3" => {
                        name: "constant.numeric.preprocessor"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        begin: "^\\s*((#)\\s*else\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.else-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        patterns: [
                            {
                                include: "$base"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        begin: "^\\s*((#)\\s*else\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.else-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        patterns: [
                            {
                                include: "#block_innards-c"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-elif" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-elif-block" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        include: "#block_innards-c"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-else" => {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    "preprocessor-rule-enabled-else-block" => {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "#block_innards-c"
            }
        ]
    },
    "preprocessor-rule-define-line-contents" => {
        patterns: [
            {
                include: "#vararg_ellipses-c"
            },
            {
                match: /##?/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
                name: "variable.other.macro.argument"
            },
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                name: "meta.block",
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-blocks"
                    }
                ]
            },
            {
                match: "\\(",
                name: "punctuation.section.parens.begin.bracket.round"
            },
            {
                match: "\\)",
                name: "punctuation.section.parens.end.bracket.round"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\s*\\()\n(?=\n  (?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name\n  |\n  (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(\n)",
                end: "(?<=\\))(?!\\w)|(?<!\\\\)(?=\\s*\\n)",
                name: "meta.function",
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#string_placeholder-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "'",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                include: "#method_access"
            },
            {
                include: "#member_access"
            },
            {
                include: "$base"
            }
        ]
    },
    "preprocessor-rule-define-line-blocks" => {
        patterns: [
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-blocks"
                    },
                    {
                        include: "#preprocessor-rule-define-line-contents"
                    }
                ]
            },
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    "preprocessor-rule-define-line-functions" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types"
            },
            {
                include: "#vararg_ellipses-c"
            },
            {
                include: "#method_access"
            },
            {
                include: "#member_access"
            },
            {
                include: "#operators"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function"
                    },
                    "2" => {
                        name: "punctuation.section.arguments.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.arguments.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    "function-innards-c" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types"
            },
            {
                include: "#operators"
            },
            {
                include: "#vararg_ellipses-c"
            },
            {
                name: "meta.function.definition.parameters",
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++ # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function"
                    },
                    "2" => {
                        name: "punctuation.section.parameters.begin.bracket.round"
                    },
                },
                end: -/\)|:/,
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parameters.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#probably_a_parameter"
                    },
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                include: "$base"
            }
        ]
    },
    "function-call-innards-c" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types"
            },
            {
                include: "#method_access"
            },
            {
                include: "#member_access"
            },
            {
                include: "#operators"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:new)\\s*(#{-maybe(template_call.without_numbered_capture_groups)}) # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "keyword.operator.memory.new"
                    },
                    "2" => {
                        patterns: [
                            {
                                include: "#template_call_innards"
                            }
                        ]
                    },
                    "3" => {
                        name: "punctuation.section.arguments.begin.bracket.round"
                    },
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.arguments.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            function_call.to_tag,
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            {
                include: "#block_innards-c"
            }
        ]
    }
})


Dir.chdir __dir__

# Save
cpp_grammar.saveAsYamlTo("./syntaxes/cpp.tmLanguage")
cpp_grammar.saveAsJsonTo("./syntaxes/cpp.tmLanguage")
