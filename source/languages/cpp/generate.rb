source_dir = "../../"
require_relative source_dir + 'textmate_tools.rb'
require_relative source_dir + 'repo_specific_helpers.rb'
require_relative source_dir + 'shared_patterns/numeric.rb'
require_relative source_dir + 'shared_patterns/trigraph_support.rb'
require_relative source_dir + 'shared_patterns/predefined_macros.rb'
require_relative './tokens.rb'

# todo
    # fix initializer list "functions" e.g. `int a{5};`
    # fix the ... inside of macros
    # have all patterns with keywords be dynamically generated

cpp_grammar = Grammar.new(
    name: "C++",
    scope_name: "source.cpp",
    version: "",
    information_for_contributors: [
        "This code was auto generated by a much-more-readble ruby file",
        "This file essentially an updated/improved fork of the atom syntax",
        "see https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master",
    ],
)

#
# Utils
#
    # inline comment
    cpp_grammar[:inline_comment] = inline_comment = newPattern(
            match: /\/\*/,
            tag_as: "comment.block punctuation.definition.comment.begin",
        ).then(
            match: /.+?/,
            tag_as: "comment.block",
        ).then(
            match: /\*\//,
            tag_as: "comment.block punctuation.definition.comment.end",
        )
    std_space = newPattern(
        # NOTE: this pattern can match 0-spaces so long as its still a word boundary
        # this is the intention since things like `int/*comment*/a = 10` are valid in c++
        # this space pattern will match inline /**/ comments that do not contain newlines
            match: oneOrMoreOf(
                quantity_preference: :as_few_as_possible,
                match: newPattern(
                    @spaces
                ).or(
                    inline_comment
                ).or(
                    @word_boundary
                ),
                includes: [
                    :inline_comment
                ]
            ),
            should_fully_match:["/*a comment*/", " /* with spaces */ "],
            should_partial_match: ["namespace{", "( A"],
        )
    cpp_grammar[:semicolon] = @semicolon = newPattern(
            match: /;/,
            tag_as: "punctuation.terminator.statement",
        )
    cpp_grammar[:comma] = newPattern(
            match: /,/,
            tag_as: "comma punctuation.separator.delimiter"
        )
    cpp_grammar[:assignment_operator] = assignment_operator = newPattern(
        match: /\=/,
        tag_as: "keyword.operator.assignment",
        )
    array_brackets = newPattern(
            match: /\[/,
            tag_as: "punctuation.definition.begin.bracket.square"
        ).then(
            match: /\w*/,
            includes: [:evaluation_context]
        ).then(
            match: /\]/,
            tag_as: "punctuation.definition.end.bracket.square"
        ).maybe(@spaces)
    # TODO eventually move this outside of the # Utils section
    ref_deref_definition_pattern = newPattern(
        should_fully_match: [ '*', '&', '**', '&&', '*&', '*&  ' ],
        should_not_fully_match: [ '&*', '&&&' ],
        match: maybe(@spaces).then(
            match: zeroOrMoreOf(/\*/.maybe(@spaces)),
            tag_as: "storage.modifier.pointer"
        ).then(
            match: /&/.maybe(@spaces),
            at_least: 0.times,
            at_most: 2.times,
            tag_as: "storage.modifier.reference"
        ).maybe(@spaces)
    )
    functionCallGenerator = ->(repository_name:nil, match_name: nil, tag_name_as: nil, tag_content_as: nil, tag_parenthese_as: nil) do
        new_range = PatternRange.new(
            tag_content_as: "meta.#{tag_content_as}",
            start_pattern: newPattern(
                    match: match_name,
                    tag_as: tag_name_as,
                ).then(
                    match: /\(/,
                    tag_as: "punctuation.section.arguments.begin.bracket.round.#{tag_parenthese_as}"
                ),
            end_pattern: newPattern(
                    match: /\)/,
                    tag_as: "punctuation.section.arguments.end.bracket.round.#{tag_parenthese_as}"
                ),
            includes: [
                :evaluation_context
            ]
            )
        if repository_name
            cpp_grammar[repository_name] = new_range
        end
        return new_range
    end
    
    def generateBlockFinder( name:"", tag_as:"", start_pattern:nil, needs_semicolon: true, primary_includes: [], head_includes:[], body_includes: [ :root_context ], tail_includes: [ :root_context ], secondary_includes:[])
        lookahead_endings = /[;>\[\]=]/
        if needs_semicolon
            end_pattern = newPattern(
                match: newPattern(
                        lookBehindFor(@close_curly_brace).maybe(@spaces).then(@semicolon)
                    ).or(
                        @semicolon
                    ).or(
                        lookAheadFor(lookahead_endings)
                    )
                )
        else
            end_pattern = lookBehindFor(@close_curly_brace).or(lookAheadFor(lookahead_endings))
        end
        return PatternRange.new(
            tag_as: tag_as,
            start_pattern: newPattern(
                    match: start_pattern,
                    tag_as: "meta.head."+name,
                ),
            end_pattern: end_pattern,
            includes: [
                *primary_includes,
                # Head
                PatternRange.new(
                    tag_as: "meta.head."+name,
                    start_pattern: /\G ?/,
                    end_pattern: newPattern(
                        match: @open_curly_brace.or(lookAheadFor(/;/)),
                        tag_as: "punctuation.section.block.begin.bracket.curly."+name
                    ),
                    includes: head_includes
                ),
                # Body
                PatternRange.new(
                    tag_as: "meta.body."+name, # body is everything in the {}'s
                    start_pattern: lookBehindFor(@open_curly_brace),
                    end_pattern: newPattern(
                            match: @close_curly_brace,
                            tag_as: "punctuation.section.block.end.bracket.curly."+name
                        ),
                    includes: body_includes
                ),
                # Tail
                PatternRange.new(
                    tag_as: "meta.tail."+name,
                    start_pattern: lookBehindFor(@close_curly_brace).then(/[\s\n]*/),
                    end_pattern: newPattern(/[\s\n]*/).lookAheadFor(/;/),
                    includes: tail_includes
                ),
                *secondary_includes
            ]
        )
    end
#
#
# Contexts
#
#
    cpp_grammar[:$initial_context] = [
            :source_wrapper,
        ]
    cpp_grammar[:root_context] = [
            :struct_declare,
            :special_block_context,
            :macro_argument,
            :string_context,
            :functional_specifiers_pre_parameters,
            :qualifiers_and_specifiers_post_parameters,
            :storage_specifiers,
            :access_control_keywords,
            :exception_keywords,
            :static_assert,
            :other_keywords,
            :memory_operators,
            :using_name,
            :the_this_keyword,
            :language_constants,
            :template_isolated_definition,
            :template_definition,
            :misc_storage_modifiers_1,
            :destructor,
            :lambdas,
            :preprocessor_context,
            :comments_context,
            :switch_statement,
            :control_flow_keywords,
            :assembly,
            :misc_storage_modifiers_2,
            :operator_overload,
            :number_literal,
            :string_context_c,
            :meta_preprocessor_macro,
            :meta_preprocessor_diagnostic,
            :meta_preprocessor_include,
            :pragma_mark,
            :meta_preprocessor_line,
            :meta_preprocessor_undef,
            :meta_preprocessor_pragma,
            :predefined_macros,
            :operators,
            :attributes_context, # this is here because it needs to be lower than :operators. TODO: once all the contexts are cleaned up, this should be put in a better spot
            :block,
            :parentheses,
            :type_casting_operators,
            :function_definition,
            :function_call,
            :scope_resolution_inner_generated,
            :storage_types,
            :line_continuation_character,
            :square_brackets,
            :empty_square_brackets,
            :semicolon,
            :comma,
        ]
    cpp_grammar[:special_block_context] = [
            # TODO: the :attributes_context probably belongs here but see issue #215 for why they were removed
            :using_namespace,
            :type_alias,
            :namespace_alias,
            :namespace_block,
            :typedef_class,
            :typedef_struct,
            :typedef_union,
            :class_block,
            :struct_block,
            :union_block,
            :enum_block,
            :extern_block,
        ]
    # this is currently just :root_context without :function_definition
    cpp_grammar[:function_body_context] = [
        :type_casting_operators,
        :function_call,
        :struct_declare,
        :special_block_context,
        :macro_argument,
        :string_context,
        :functional_specifiers_pre_parameters,
        :qualifiers_and_specifiers_post_parameters,
        :storage_specifiers,
        :access_control_keywords,
        :exception_keywords,
        :static_assert,
        :other_keywords,
        :memory_operators,
        :using_name,
        :the_this_keyword,
        :language_constants,
        :template_isolated_definition,
        :template_definition,
        :misc_storage_modifiers_1,
        :destructor,
        :lambdas,
        :preprocessor_context,
        :comments_context,
        :switch_statement,
        :control_flow_keywords,
        :assembly,
        :misc_storage_modifiers_2,
        :operator_overload,
        :number_literal,
        :string_context_c,
        :meta_preprocessor_macro,
        :meta_preprocessor_diagnostic,
        :meta_preprocessor_include,
        :pragma_mark,
        :meta_preprocessor_line,
        :meta_preprocessor_undef,
        :meta_preprocessor_pragma,
        :operators,
        :block,
        :c_style_type_casting,
        :parentheses,
        :type_casting_operators,
        :scope_resolution_inner_generated,
        :storage_types,
        :line_continuation_character,
        :square_brackets,
        :empty_square_brackets,
        :semicolon,
        :comma,
    ]
    cpp_grammar[:preprocessor_context] = [
            :preprocessor_rule_enabled,
            :preprocessor_rule_disabled,
            :preprocessor_rule_conditional,
            :hacky_fix_for_stray_directive,
        ]
    cpp_grammar[:storage_types] = [
            :storage_specifiers,
            :primitive_types,
            :non_primitive_types,
            :pthread_types,
            :posix_reserved_types,
            :decltype,
        ]
    cpp_grammar[:function_parameter_context] = [
            :parameter_struct,
            :probably_a_parameter,
            :attributes_context,
            :comments_context,
            :storage_types,
            :vararg_ellipses,
            :function_pointer_parameter,
            :comma,
            # the following are a temp workaround for defaulted arguments
            # e.g. aFunc(int a = 10 + 10)
            :language_constants,
            :number_literal,
            :string_context,
            :operators,
        ]
    # eventually this context will be more exclusive (can't have class definitons inside of an evaluation)
    # but for now it just includes everything
    cpp_grammar[:evaluation_context] = [
            :root_context
            # function call
            # number literal
            # lambdas
        ]
    # eventually this context will be more exclusive (can't have class definitons inside of an if statement)
    # but for now it just includes everything
    cpp_grammar[:conditional_context] = [
            :root_context
        ]
    cpp_grammar[:template_definition_context] = [
            :scope_resolution_template_definition_inner_generated,
            :template_definition_argument,
            :template_argument_defaulted,
            :template_call_innards,
            :evaluation_context
        ]
    cpp_grammar[:template_call_context] = [
            :storage_types,
            :language_constants,
            :scope_resolution_template_call_inner_generated,
            :user_defined_template_type,
            :operators,
            :number_literal,
            :string_context,
            :comma_in_template_argument
        ]
    cpp_grammar[:attributes_context] = [
        :cpp_attributes,
        :gcc_attributes,
        :ms_attributes,
        :alignas_attribute,
    ]
# 
# source wrapper
# 
    # everthing is wrapped inside this context, and it should only be matched once
    # this exists so that `source.cpp` will exist even inside of embedded files (like markdown)
    cpp_grammar[:source_wrapper] = [
        PatternRange.new(
            # the first position
            start_pattern: lookAheadFor(/^/),
            # ensure end never matches
            # why? because textmate will keep looking until it hits the end of the file (which is the purpose of this wrapper)
            # how? because the regex is trying to find "not" and then checks to see if "not" == "possible" (which can never happen)
            end_pattern: /not/.lookBehindFor(/possible/),
            tag_as: "source",
            includes: [:root_context],
        ),
    ]

#
#
# Numbers
#
#
    #
    # Number Literal
    #
    cpp_grammar[:number_literal] = numeric_constant(allow_user_defined_literals: true)
#
# Variable
#
    universal_character = /\\u[0-9a-fA-F]{4}/.or(/\\U[0-9a-fA-F]{8}/)
    first_character = /[a-zA-Z_]/.or(universal_character)
    subsequent_character = /[a-zA-Z0-9_]/.or(universal_character)
    identifier = first_character.then(zeroOrMoreOf(subsequent_character))
    # todo: make a better name for this function
    variableBounds = ->(regex_pattern) do
        lookBehindToAvoid(@standard_character).then(regex_pattern).lookAheadToAvoid(@standard_character)
    end
    variable_name_without_bounds = identifier
    # word bounds are inefficient, but they are accurate
    variable_name = variableBounds[variable_name_without_bounds]

#
# Constants
#
    cpp_grammar[:language_constants] = newPattern(
        match: variableBounds[@cpp_tokens.that(:isLiteral)],
        tag_as: "constant.language.$match"
        )

#
# Built-In Types
#
    look_behind_for_type = lookBehindFor(/\w |\*\/|[&*>\]\)]|\.\.\./).maybe(@spaces)
    cpp_grammar[:primitive_types] = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isPrimitive) ],
        tag_as: "storage.type.primitive storage.type.built-in.primitive"
        )
    cpp_grammar[:non_primitive_types] = newPattern(
        match: variableBounds[@cpp_tokens.that(not(:isPrimitive), :isType)],
        tag_as: "storage.type storage.type.built-in"
        )
    cpp_grammar[:decltype] = functionCallGenerator[
                repository_name: "decltype_specifier",
                match_name: variableBounds[/decltype/],
                tag_name_as: "keyword.operator.functionlike keyword.other.decltype storage.type.decltype",
                tag_content_as: "arguments.decltype",
                tag_parenthese_as: "decltype"
            ]

#
# Keywords and Keyword-ish things
#
    cpp_grammar[:using_name] = newPattern(match: /using/, tag_as: "keyword.other.using.directive").then(@spaces).lookAheadToAvoid(/namespace\b/)
    cpp_grammar[:functional_specifiers_pre_parameters] = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isFunctionSpecifier) ],
        tag_as: "storage.modifier.specifier.functional.pre-parameters.$match"
        )
    cpp_grammar[:qualifiers_and_specifiers_post_parameters] = newPattern(
        match: variableBounds[ @cpp_tokens.that(:canAppearAfterParametersBeforeBody) ].lookAheadFor(/\s*/.then(/\{/.or(/;/).or(/[\n\r]/))),
        tag_as: "storage.modifier.specifier.functional.post-parameters.$match"
        )
    cpp_grammar[:storage_specifiers] = storage_specifier = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isStorageSpecifier) ],
        tag_as: "storage.modifier.specifier.$match"
        )
    cpp_grammar[:access_control_keywords] = newPattern(
        tag_as: "storage.type.modifier.access.control.$reference(access_specifier)",
        match: lookBehindToAvoid(@standard_character).then(
                match: @cpp_tokens.that(:isAccessSpecifier),
                reference: "access_specifier"
            ).maybe(@spaces).then(
                match: /:/,
                tag_as: "colon"
            ),
        )
    cpp_grammar[:exception_keywords] = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isExceptionRelated) ],
        tag_as: "keyword.control.exception.$match"
        )
    cpp_grammar[:other_keywords] = newPattern(
        match: variableBounds[ /(typedef)/ ],
        tag_as: "keyword.other.$match"
        )
    cpp_grammar[:the_this_keyword] = the_this_keyword = newPattern(
        match: variableBounds[ /this/ ],
        tag_as: "variable.language.this"
        )
    # TODO: enhance casting operators to include <>'s
    cpp_grammar[:type_casting_operators] = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isTypeCastingOperator) ],
        tag_as: "keyword.operator.wordlike keyword.operator.cast.$match"
        )
    cpp_grammar[:memory_operators] = newPattern(
        tag_as: "keyword.operator.wordlike memory",
        match: lookBehindToAvoid(
                @standard_character
            ).then(
                newPattern(
                    newPattern(
                        match: /delete/,
                        tag_as: "keyword.operator.delete.array"
                    ).maybe(@spaces).then(
                        match: /\[\]/,
                        tag_as: "keyword.operator.delete.array.bracket"
                    )
                ).or(
                    match: /delete/,
                    tag_as: "keyword.operator.delete"
                ).or(
                    match: /new/,
                    tag_as: "keyword.operator.new"
                )
            ).lookAheadToAvoid(@standard_character)
        )
    cpp_grammar[:control_flow_keywords] = control_flow_keywords = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isControlFlow) ],
        tag_as: "keyword.control.$match"
        )
    declaration_storage_specifiers = newPattern(
        match: zeroOrMoreOf(storage_specifier.without_numbered_capture_groups.then(@spaces)),
        includes: [
            :storage_specifiers
        ]
        )
#
# Control flow
#
    cpp_grammar[:default_statement] = PatternRange.new(
            tag_as: "meta.conditional.case",
            start_pattern: newPattern(
                match: variableBounds[ /default/ ],
                tag_as: "keyword.control.default"
            ),
            end_pattern: newPattern(
                match: /:/,
                tag_as: "colon punctuation.separator.case.default"
            ),
            includes: [:conditional_context]
        )
    cpp_grammar[:case_statement] = PatternRange.new(
            tag_as: "meta.conditional.case",
            start_pattern: newPattern(
                match: variableBounds[ /case/ ],
                tag_as: "keyword.control.case"
            ),
            end_pattern: newPattern(
                match: /:/,
                tag_as: "colon punctuation.separator.case"
            ),
            includes: [:conditional_context]
        )
    cpp_grammar[:switch_conditional_parentheses] = PatternRange.new(
            tag_as: "meta.conditional.switch",
            start_pattern: newPattern(
                match: /\(/,
                tag_as: 'punctuation.section.parens.begin.bracket.round.conditional.switch'
            ),
            end_pattern: newPattern(
                match: /\)/,
                tag_as: 'punctuation.section.parens.end.bracket.round.conditional.switch'
            ),
            includes: [ :conditional_context ]
        )
    cpp_grammar[:switch_statement] = generateBlockFinder(
            name: "switch",
            tag_as: "meta.block.switch",
            start_pattern: newPattern(
                match: variableBounds[/switch/],
                tag_as: "keyword.control.switch"
            ),
            head_includes: [
                :switch_conditional_parentheses,
                :root_context
            ],
            body_includes: [
                :default_statement,
                :case_statement,
                :root_context,
                :block_innards # this is just for C support, it should be removed in the future
            ],
            needs_semicolon: false,
        )
#
# C++ Attributes
#
    generateAttributeRangeFinder = ->(start_pattern, end_pattern) do
        return PatternRange.new(
            tag_as: "support.other.attribute",
            start_pattern: newPattern(
                match: start_pattern,
                tag_as: "punctuation.section.attribute.begin",
            ),
            end_pattern: newPattern(
                match: end_pattern,
                tag_as: "punctuation.section.attribute.end",
            ),
            includes: [
                # allow nested attributes
                :attributes_context,
                PatternRange.new(
                    start_pattern: /\(/,
                    end_pattern: /\)/,
                    includes: [
                        :attributes_context,
                        :string_context_c,
                    ],
                ),
                newPattern(match: /using/, tag_as: "keyword.other.using.directive").then(@spaces).then(
                    match: variable_name,
                    tag_as: "entity.name.namespace",
                ),
                newPattern(match: /,/, tag_as: "punctuation.separator.attribute"),
                newPattern(match: /:/, tag_as: "punctuation.accessor.attribute"),
                newPattern(
                    match: variable_name.lookAheadFor(/::/),
                    tag_as: "entity.name.namespace"
                ),
                newPattern(match: variable_name, tag_as: "entity.other.attribute.$match"),
                :number_literal,
            ]
        )
    end
    
    cpp_attribute_start = /\[\[/
    cpp_attribute_end   = /\]\]/
    gcc_attribute_start = /__attribute(?:__)?\(\(/
    gcc_attribute_end   = /\)\)/
    ms_attribute_start  = /__declspec\(/
    ms_attribute_end    = /\)/
    alignas_start       = /alignas\(/
    alignas_end         = /\)/
    
    cpp_grammar[:cpp_attributes   ] = generateAttributeRangeFinder[ cpp_attribute_start, cpp_attribute_end ]
    cpp_grammar[:gcc_attributes   ] = generateAttributeRangeFinder[ gcc_attribute_start, gcc_attribute_end ]
    cpp_grammar[:ms_attributes    ] = generateAttributeRangeFinder[ ms_attribute_start , ms_attribute_end  ]
    cpp_grammar[:alignas_attribute] = generateAttributeRangeFinder[ alignas_start      , alignas_end       ]
    
    inline_attribute = newPattern(
        should_fully_match:["[[nodiscard]]","__attribute((packed))","__declspec(fastcall)","__attribute__((constructor(101)))"],
        should_partial_match: ["struct [[deprecated]] st"],
        # match one of the three attribute styles
        match: newPattern(
                cpp_attribute_start.then(/.*?/).then(cpp_attribute_end)
            ).or(
                gcc_attribute_start.then(/.*?/).then(gcc_attribute_end)
            ).or(
                ms_attribute_start.then(/.*?/).then(ms_attribute_end)
            ).or(
                alignas_start.then(/.*?/).then(alignas_end)
            ).lookAheadToAvoid(/\)/),
        includes: [
            :attributes_context,
            :number_literal, # for alignas
        ],
    )
#
# Templates
#
    characters_in_template_call = /[\(\)\s<>:,\w]/
    no_brackets_at_all = /[^<>]*/
    balanced_brackets = /[^>]*+<[^>]*+>/
    some_number_of_angle_brackets = oneOrMoreOf(no_brackets_at_all.or(balanced_brackets))
    # TODO: change this to a readble form (above) once possessives (aka no back_track) is imlpemented
    # otherwise this pattern fails because its to computationally expensive
    some_number_of_angle_brackets = /(?:[^<>]*|[^>]*+<[^>]*+>)++/
    
    cpp_grammar[:user_defined_template_type] = newPattern(
            match: variable_name,
            tag_as: 'storage.type.user-defined'
        )
    cpp_grammar[:comma_in_template_argument] = newPattern(
            match: /,/,
            tag_as: "comma punctuation.separator.template.argument"
        )
    # note: template_call should indeally be a Range(), the reason its not is
    # because it's embedded inside of other patterns
    cpp_grammar[:template_call_innards] = template_call = newPattern(
        tag_as: 'meta.template.call',
        # if we add readable-support for recursive regex, then we might be able to use /<((?>[^<>]+|(\g<#groupNumberOfThisGroup>))*)>/ 
        # to match the characters in the middle of a template call
        match: lookBehindToAvoid(/</).then(/</).lookAheadToAvoid(/</).then(some_number_of_angle_brackets).then(/>/).maybe(@spaces),
        includes: [ :template_call_range ]
        )
    cpp_grammar[:template_call_range] = PatternRange.new(
            tag_as: 'meta.template.call',
            start_pattern: newPattern(
                match: /</,
                tag_as: "punctuation.section.angle-brackets.begin.template.call"
            ),
            end_pattern: newPattern(
                match: />/,
                tag_as: "punctuation.section.angle-brackets.end.template.call"
            ),
            includes: [:template_call_context]
        )
    template_start = lookBehindToAvoid(@standard_character).then(
            match: /template/,
            tag_as: "storage.type.template"
        ).maybe(@spaces).then(
            match: /</,
            tag_as: "punctuation.section.angle-brackets.start.template.definition"
        )
    # a template definition that is by itself on a line (this is ideal)
    cpp_grammar[:template_isolated_definition] = newPattern(
        match: template_start.then(
                match:  zeroOrMoreOf(/./),
                tag_as: "meta.template.definition",
                includes: [:template_definition_context],
            ).then(
                match: />/.maybe(@spaces).then(/$/),
                tag_as: "punctuation.section.angle-brackets.end.template.definition"
            ),
        )
    cpp_grammar[:template_definition] = PatternRange.new(
        tag_as: 'meta.template.definition',
        start_pattern: template_start,
        end_pattern: newPattern(
                match: />/,
                tag_as: "punctuation.section.angle-brackets.end.template.definition"
            ),
        includes: [
            # a template call inside of a non-isolated template definition
            # however this is rolling the dice: because if there is a less-than operator in a defaulted argument, then this pattern will screw everything up
            # a better solution would be nice, but its going to be difficult/impossible
            PatternRange.new(
                start_pattern: newPattern(
                        match: lookBehindFor(/\w/).maybe(@spaces).then(/</),
                        tag_as: "punctuation.section.angle-brackets.begin.template.call"
                    ),
                end_pattern: newPattern(
                        match: />/,
                        tag_as: "punctuation.section.angle-brackets.begin.template.call"
                    ),
                includes: [:template_call_context]
            ),
            :template_definition_context,
        ]
        )
    cpp_grammar[:template_argument_defaulted] = newPattern(
        match: lookBehindFor(/<|,/).maybe(@spaces).then(
                match: zeroOrMoreOf(variable_name_without_bounds.then(@spaces)),
                tag_as: "storage.type.template",
            ).then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.type.template"
            ).maybe(@spaces).then(
                match: /[=]/,
                tag_as: "keyword.operator.assignment"
            )
        )
    cpp_grammar[:template_definition_argument] = newPattern(
        match: maybe(
                @spaces
            # case 1: only one word
            ).then(
                match: variable_name_without_bounds,
                tag_as: "storage.type.template.argument.$match",
            # case 2: normal situation (ex: "typename T")
            ).or(
                newPattern(
                    match: oneOrMoreOf(variable_name_without_bounds.then(@spaces)),
                    includes: [
                        newPattern(
                            match: variable_name_without_bounds,
                            tag_as: "storage.type.template.argument.$match",
                        )
                    ],
                ).then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.type.template",
                )
            # case 3: ellipses (ex: "typename... Args")
            ).or(
                newPattern(
                    match: variable_name_without_bounds,
                    tag_as: "storage.type.template",
                ).maybe(@spaces).then(
                    match: /\.\.\./,
                    tag_as: "ellipses punctuation.vararg-ellipses.template.definition",
                ).maybe(@spaces).then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.type.template"
                )
            ).maybe(@spaces).then(
                newPattern(
                    match: /,/,
                    tag_as: "comma punctuation.separator.template.argument",
                ).or(
                    lookAheadFor(/>|$/)
                )
            )
        )
#
# Scope resolution
#
    one_scope_resolution = variable_name_without_bounds.then(/\s*+/).maybe(template_call.without_numbered_capture_groups).then(/::/)
    preceding_scopes = newPattern(
        match: maybe(/::/).zeroOrMoreOf(one_scope_resolution).maybe(@spaces),
        includes: [ :scope_resolution_inner_generated ]
        )
    generateScopeResolutionFinder = ->(tag_extension, grammar_name) do
        hidden_grammar_name = (grammar_name.to_s+"_inner_generated").to_sym
        cpp_grammar[grammar_name] = newPattern(
            # find the whole scope resolution 
            should_fully_match: [ "name::name2::name3::" ],
            match: maybe(/::/).zeroOrMoreOf(one_scope_resolution).then(/\s*+/),
            includes: [
                    # then tag every `name::` seperately 
                    hidden_grammar_name,
                ]
            )
        cpp_grammar[hidden_grammar_name] = newPattern(
            should_fully_match: ["name::", "name::name2::name3::"],
            match: cpp_grammar[grammar_name].then(
                    match: variable_name_without_bounds,
                    tag_as: "entity.name.scope-resolution"+tag_extension
                ).then(/\s*+/).maybe(
                    template_call
                ).then(
                    match: /::/,
                    tag_as: "punctuation.separator.namespace.access punctuation.separator.scope-resolution"+tag_extension
                ),
            )
    end
    scope_resolution = generateScopeResolutionFinder["", :scope_resolution]
    generateScopeResolutionFinder[".template.call"       ,:scope_resolution_template_call       ]
    generateScopeResolutionFinder[".template.definition" ,:scope_resolution_template_definition ]
    generateScopeResolutionFinder[".function.call"       ,:scope_resolution_function_call       ]
    generateScopeResolutionFinder[".function.definition" ,:scope_resolution_function_definition ]
    generateScopeResolutionFinder[".namespace.alias"     ,:scope_resolution_namespace_alias     ]
    generateScopeResolutionFinder[".namespace.using"     ,:scope_resolution_namespace_using     ]
    generateScopeResolutionFinder[".namespace.block"     ,:scope_resolution_namespace_block     ]
    generateScopeResolutionFinder[".function.definition.operator-overload" ,:scope_resolution_function_definition_operator_overload]
    
#
# Types
#
    non_type_keywords = @cpp_tokens.that(:isWord, not(:isType), not(:isTypeCreator))
    builtin_type_creators_and_specifiers = @cpp_tokens.that(:isTypeSpecifier).or(@cpp_tokens.that(:isTypeCreator))
    cpp_grammar[:qualified_type] = qualified_type = newPattern(
        should_fully_match: ["A","A::B","A::B<C>::D<E>", "unsigned char","long long int", "unsigned short int","struct a", "void", "a::more::<complex, type>"],
        should_not_partial_match: ["return", "static const"],
        tag_as: "meta.qualified_type",
        match: /\s*+/.lookAheadFor(
                /\w/
            ).lookBehindToAvoid(
                /\w/
            ).maybe(
                inline_attribute
            ).then(/\s*+/).zeroOrMoreOf(
                builtin_type_creators_and_specifiers.then(/\s++/)
            ).maybe(
                scope_resolution
            ).then(/\s*+/).then(
                match: identifier,
                tag_as: "entity.name.type",
            ).then(@word_boundary).then(
                lookBehindToAvoid(non_type_keywords)
            ).maybe(
                template_call.without_numbered_capture_groups
            ).lookAheadToAvoid(/[\w<:.]/),
        includes: [
            newPattern(match: @cpp_tokens.that(:isTypeCreator), tag_as: "storage.type.$match"),
            :function_type,
            :storage_types,
            :number_literal,
            :string_context_c,
            :comma,
            :scope_resolution_inner_generated,
            cpp_grammar[:template_call_range],
            newPattern(
                match: identifier,
                tag_as: "entity.name.type",
            ),
        ],
    )
    cpp_grammar[:type_alias] = newPattern(
        tag_as: "meta.declaration.type.alias",
        should_fully_match: ["using A = B;", "using _Sat = std::allocator_traits<Allocator>;","using const_pointer_t = const uint8_t *\n","using T = typename std::iterator_traits<InputIt>::value_type;", "using pcb = details::pointer_control_block<Y, default_delete<Y>>;"],
        should_not_partial_match: ["using namespace std;","using std::swap;", "using B::B;"],
        match: newPattern(
                match:/using/,
                tag_as: "keyword.other.using.directive",
            ).maybe(@spaces).lookAheadToAvoid(/namespace/).then(
                qualified_type
            ).maybe(@spaces).then(
                assignment_operator
            ).maybe(@spaces).maybe(
                match: /typename/,
                tag_as: "keyword.other.typename",
            ).maybe(@spaces).then(
                declaration_storage_specifiers
            ).then(
                qualified_type.or(
                    match: /.+/.lookBehindToAvoid(/;/),
                    tag_as: "meta.declaration.type.alias.value.unknown",
                    includes: [
                        :evaluation_context,
                    ]
                )
            ).then(
                ref_deref_definition_pattern
            ).maybe(
                array_brackets
            ).maybe(@spaces).then(@semicolon.or(/\n/)),
    )
    cpp_grammar[:c_style_type_casting] = newPattern(
        tag_as: "meta.type.cast",
        should_fully_match: ["(int)", "( char * )", "(a::more::<complex, type> )"],
        should_not_partial_match: ["foo(bar)"],
        match: lookBehindToAvoid(/[\w\s>]/).maybe(@spaces).then(
            /\(/.maybe(@spaces).then(qualified_type).then(ref_deref_definition_pattern).then(/\)/)
        ).lookAheadToAvoid(maybe(@spaces).then(@semicolon))
    )
#
# Functions
#
    cant_be_a_function_name = @cpp_tokens.that(:isWord,  not(:isPreprocessorDirective), not(:isValidFunctionName))
    avoid_invalid_function_names = lookBehindToAvoid(@standard_character).lookAheadToAvoid(maybe(@spaces).then(cant_be_a_function_name).maybe(@spaces).then(/\(/))
    look_ahead_for_function_name = lookAheadFor(variable_name_without_bounds.maybe(@spaces).maybe(inline_attribute).maybe(@spaces).then(/\(/))
    cpp_grammar[:struct_declare] = struct_declare = newPattern(
            should_partial_match: [ "struct crypto_aead *tfm = crypto_aead_reqtfm(req);", "struct aegis_block blocks[AEGIS128L_STATE_BLOCKS];" ],
            match: newPattern(
                match: /struct/,
                tag_as: "storage.type.struct.declare",
            ).then(@spaces).then(
                match: variable_name,
                tag_as: "entity.name.type.struct",
            ).maybe(@spaces).then(
                ref_deref_definition_pattern.or(@spaces)
            ).then(
                match: variable_name,
                tag_as: "variable.other.object.declare",
            )
        )
    cpp_grammar[:parameter_struct] = newPattern(
            should_partial_match: [ "struct skcipher_walk *walk," ],
            match: newPattern(
                match: /struct/,
                tag_as: "storage.type.struct.parameter",
            ).then(@spaces).then(
                match: variable_name,
                tag_as: "entity.name.type.struct.parameter",
            ).maybe(@spaces).then(
                ref_deref_definition_pattern.or(@spaces)
            # this is a maybe because its possible to have a type declare without an actual parameter
            ).maybe(
                match: variable_name,
                tag_as: "variable.other.object.declare",
            ).maybe(@spaces).maybe(
                /\[/.maybe(@spaces).then(/\]/).maybe(@spaces),
            ).lookAheadFor(/,|\)|\n/)
        )
        
    cpp_grammar[:function_definition] = generateBlockFinder(
        name:"function.definition",
        tag_as:"meta.function.definition",
        start_pattern: newPattern(
            qualified_type.then(@spaces.or(ref_deref_definition_pattern)).then(
                cpp_grammar[:scope_resolution_function_definition]
            ).then(
                avoid_invalid_function_names
            ).then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.function.definition"
            ).maybe(@spaces).lookAheadFor(/\(/)
        ),
        head_includes:[
            PatternRange.new(
                tag_content_as: "meta.function.definition.parameters",
                start_pattern: newPattern( 
                    match: /\(/,
                    tag_as: "punctuation.section.parameters.begin.bracket.round"
                    ),
                end_pattern: newPattern( 
                    match: /\)/,
                    tag_as: "punctuation.section.parameters.end.bracket.round"
                    ),
                includes: [
                    :function_parameter_context,
                    # TODO: the function_call_context is included here as workaround for function-initializations like issue #198
                    # e.g. std::string ("hello");
                    :function_call_context,
                ]
            ),
            :comments_context,
            # initial context is here for things like noexcept()
            # TODO: fix this pattern an make it more strict
            :root_context
        ],
        needs_semicolon: false,
        body_includes: [ :function_body_context ],
    )
    # static assert is special as it can be outside of normal places function calls can be
    cpp_grammar[:static_assert] = PatternRange.new(
        start_pattern: newPattern(
            match: /static_assert|_Static_assert/,
            tag_as: "keyword.other.static_assert",
        ).maybe(@spaces).then(
            match: /\(/,
            tag_as: "punctuation.section.arguments.begin.bracket.round",
        ),
        end_pattern: newPattern(
            match: /\)/,
            tag_as: "punctuation.section.arguments.end.bracket.round",
        ),
        includes: [
            # special handling for the assert message
            PatternRange.new(
                start_pattern: newPattern(
                    match: /,/,
                    tag_as: "comma punctuation.separator.delimiter",
                ).maybe(@spaces).lookAheadFor(maybe(/L|u8|u|U/.maybe(@spaces).then(/\"/))),
                end_pattern: lookAheadFor(/\)/),
                tag_as: "meta.static_assert.message",
                includes: [
                    :string_context,
                    :string_context_c,
                ]
            ),
            :function_call_context,
        ]
    )
    # a full match example of function call would be: aNameSpace::subClass<TemplateArg>FunctionName<5>(
    cpp_grammar[:function_call] = PatternRange.new(
        start_pattern: lookAheadToAvoid(@space).then(
                avoid_invalid_function_names
            ).then(
                cpp_grammar[:scope_resolution_function_call]
            ).then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.function.call"
            ).maybe(@spaces).maybe(
                template_call
            ).then(
                match: /\(/,
                tag_as: "punctuation.section.arguments.begin.bracket.round.function.call"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.arguments.end.bracket.round.function.call"
            ),
        includes: [ :function_call_context ]
        )
#
# Operators
#
    cpp_grammar[:operators] = []
    normal_word_operators = newPattern(
        match: variableBounds[ @cpp_tokens.that(:isOperator, :isWord, not(:isTypeCastingOperator), not(:isControlFlow), not(:isFunctionLike)) ],
        tag_as: "keyword.operator.wordlike alias keyword.operator.$match",
        )
    array_of_function_like_operators = @cpp_tokens.tokens.select { |each| each[:isFunctionLike] && !each[:isSpecifier] }
    for each in array_of_function_like_operators
        name = each[:name]
        cpp_grammar[:operators].push(functionCallGenerator[
            repository_name: "#{name}_operator",
            match_name: variableBounds[/#{name}/],
            tag_name_as: "keyword.operator.functionlike keyword.operator.#{name}",
            tag_content_as: "arguments.operator.#{name}",
            tag_parenthese_as: "operator.#{name}"
        ])
    end
        
    cpp_grammar[:operators] += [
            :method_access,
            :member_access,
            normal_word_operators,
            :vararg_ellipses,
            {
                match: "--",
                name: "keyword.operator.decrement"
            },
            {
                match: "\\+\\+",
                name: "keyword.operator.increment"
            },
            {
                match: "%=|\\+=|-=|\\*=|(?<!\\()/=",
                name: "keyword.operator.assignment.compound"
            },
            {
                match: "&=|\\^=|<<=|>>=|\\|=",
                name: "keyword.operator.assignment.compound.bitwise"
            },
            {
                match: "<<|>>",
                name: "keyword.operator.bitwise.shift"
            },
            {
                match: "!=|<=|>=|==|<|>",
                name: "keyword.operator.comparison"
            },
            {
                match: "&&|!|\\|\\|",
                name: "keyword.operator.logical"
            },
            {
                match: "&|\\||\\^|~",
                name: "keyword.operator"
            },
            :assignment_operator,
            {
                match: "%|\\*|/|-|\\+",
                name: "keyword.operator"
            },
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                applyEndPatternLast: true,
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#method_access"
                    },
                    {
                        include: "#member_access"
                    },
                    {
                        include: "#function_call_c"
                    },
                    {
                        include: "#root_context"
                    }
                ]
            }
        ]
#
# function pointer
#
    after_declaration = maybe(@spaces).lookAheadFor(/[{=,);]|\n/).lookAheadToAvoid(/\(/)
    functionPointerGenerator = ->(identifier_tag) do
        return PatternRange.new(
            start_pattern: qualified_type.maybe(@spaces).then(ref_deref_definition_pattern).then(
                    match: /\(/,
                    tag_as: "punctuation.section.parens.begin.bracket.round.function.pointer"
                ).then(
                    match: /\*/,
                    tag_as: "punctuation.definition.function.pointer.dereference",
                ).maybe(@spaces).maybe(
                    match: identifier,
                    tag_as: identifier_tag
                ).maybe(@spaces).zeroOrMoreOf(
                    # an array of function pointers ?
                    array_brackets
                ).then(
                    # closing ) for the variable name
                    match: /\)/,
                    tag_as: "punctuation.section.parens.end.bracket.round.function.pointer"
                ).maybe(@spaces).then(
                    # opening ( for the parameter types
                    match: /\(/,
                    tag_as: "punctuation.section.parameters.begin.bracket.round.function.pointer"
                ),
            end_pattern: newPattern(
                    match: /\)/,
                    tag_as: "punctuation.section.parameters.end.bracket.round.function.pointer"
                ).then(after_declaration),
            includes: [
                :function_parameter_context,
            ]
        )
    end
    cpp_grammar[:function_pointer] = functionPointerGenerator["variable.other.definition.pointer.function"]
    cpp_grammar[:function_pointer_parameter] = functionPointerGenerator["variable.parameter.pointer.function"]
#
# Probably a parameter
#
    array_brackets = /\[\]/.maybe(@spaces)
    comma_or_closing_paraenthese = /,/.or(/\)/)
    stuff_after_a_parameter = maybe(@spaces).lookAheadFor(maybe(array_brackets).then(comma_or_closing_paraenthese))
    cpp_grammar[:probably_a_parameter] = newPattern(
        match: newPattern(
                match: variable_name_without_bounds.maybe(@spaces).lookAheadFor("="),
                tag_as: "variable.parameter.defaulted"
            ).or(
                match: look_behind_for_type.lookAheadToAvoid(@cpp_tokens.that(:isType)).then(variable_name_without_bounds).then(stuff_after_a_parameter),
                tag_as: "variable.parameter"
            )
        )

#
# Operator overload
#
    # symbols can have spaces
    operator_symbols = maybe(@spaces).then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isSymbol))
    # words must have spaces, the variable_name_without_bounds is for implicit overloads
    operator_wordish = @spaces.then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isWordish).or(zeroOrMoreOf(one_scope_resolution).then(variable_name_without_bounds).maybe(@spaces).maybe(/&/)))
    after_operator_keyword = operator_symbols.or(operator_wordish)
    cpp_grammar[:operator_overload] = operator_overload = PatternRange.new(
        tag_as: "meta.function.definition.parameters.operator-overload",
        start_pattern: newPattern(
                match: /operator/,
                tag_as: "keyword.other.operator.overload",
            ).then(
                match: after_operator_keyword,
                tag_as: "entity.name.operator.overloadee",
                includes: [:scope_resolution_function_definition_operator_overload_inner_generated]
            ).maybe(@spaces).then(
                match: /\(/,
                tag_as: "punctuation.section.parameters.begin.bracket.round.operator-overload"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.parameters.end.bracket.round.operator-overload"
            ),
        includes: [ :function_parameter_context ]
        )

#
# Access . .* -> ->*
#
    dot_operator = /\.\*/.or(/\./)
    arrow_operator = /->\*/.or(/->/)
    dot_or_arrow_operator = /(?:\.\*|\.|->|->\*)/
    member_operator = newPattern(
            match: dot_operator,
            tag_as: "punctuation.separator.dot-access"
        ).or(
            match: arrow_operator,
            tag_as: "punctuation.separator.pointer-access"
        )
    subsequent_object_with_operator = variable_name_without_bounds.maybe(@spaces).then(member_operator.without_numbered_capture_groups).maybe(@spaces)
    # TODO: the member_access and method_access can probably be simplified considerably
    # TODO: member_access and method_access might also need additional matching to handle scope resolutions
    generatePartialMemberFinder = ->(tag_name) do
        the_this_keyword.or(
            newPattern(
                match: variable_name_without_bounds.or(lookBehindFor(/\]|\)/)).maybe(@spaces),
                tag_as: tag_name,
            )
        ).then(
            member_operator
        )
    end
    partial_member = generatePartialMemberFinder["variable.other.object.access"] 
    member_context = [
            mid_member = newPattern(
                match: lookBehindFor(dot_or_arrow_operator).maybe(
                    @spaces
                ).then(
                    generatePartialMemberFinder["variable.other.object.property"]
                )
            ),
            partial_member,
            :member_access,
            :method_access,
        ]
    member_start = partial_member.then(
            match: zeroOrMoreOf(subsequent_object_with_operator),
            includes: member_context
        ).maybe(@spaces)
    # access to attribute
    type_represenetations = @cpp_tokens.representationsThat(:isType)
    lookahead_friedly_types_pattern = /#{type_represenetations.map { |each| each+"[^#{@standard_character}]" } .join('|')}/
    cpp_grammar[:member_access] = member_access = newPattern(
        match: member_start.then(
                match: @word_boundary.lookAheadToAvoid(lookahead_friedly_types_pattern).then(variable_name_without_bounds).then(@word_boundary).lookAheadToAvoid(/\(/),
                tag_as: "variable.other.property"
            )
        )
    # access to method
    cpp_grammar[:method_access] = method_access = PatternRange.new(
        start_pattern: member_start.then(
                match: variable_name_without_bounds,
                tag_as: "entity.name.function.member"
            ).maybe(@spaces).then(
                match: /\(/,
                tag_as: "punctuation.section.arguments.begin.bracket.round.function.member"
            ),
        end_pattern: newPattern(
                match: /\)/,
                tag_as: "punctuation.section.arguments.end.bracket.round.function.member"
            ),
        includes: [:function_call_context],
        )
#
# Namespace
#
    # see https://en.cppreference.com/w/cpp/language/namespace
    cpp_grammar[:using_namespace] = PatternRange.new(
        tag_as: "meta.using-namespace",
        start_pattern: lookBehindToAvoid(@standard_character).then(
                match: /using/,
                tag_as: "keyword.other.using.directive",
            ).then(@spaces).then(
                match: /namespace/,
                tag_as: "keyword.other.namespace.directive storage.type.namespace.directive"
            ).then(@spaces).maybe(
                cpp_grammar[:scope_resolution_namespace_using]
            ).then(
                match: variable_name,
                tag_as: "entity.name.namespace"
            ).lookAheadFor(
                /;|\n/
            ),
        end_pattern: @semicolon,
        )
    cpp_grammar[:namespace_alias] = newPattern(
        tag_as: "meta.declaration.namespace.alias",
        should_fully_match: ["namespace foo = bar;", "namespace fs=boost::filesystem;", "namespace std = ::std;"],
        should_not_partial_match: ["namespace foo {", "using namespace std;"],
        match: lookBehindToAvoid(@standard_character).then(
                    match: /namespace/,
                    tag_as: "keyword.other.namespace.alias storage.type.namespace.alias"
                ).then(@spaces).then(
                    match: variable_name,
                    tag_as: "entity.name.namespace.alias",
                ).maybe(@spaces).then(assignment_operator).maybe(@spaces).then(
                    tag_as: "meta.declaration.namespace.alias.value",
                    match: cpp_grammar[:scope_resolution_namespace_alias].maybe(@spaces).then(
                            match: variable_name,
                            tag_as: "entity.name.namespace",
                    ).maybe(@spaces).then(
                        @semicolon.or(/\n/)
                    ),
                ),
    )
    cpp_grammar[:namespace_block] = generateBlockFinder(
        name: "namespace",
        tag_as: "meta.block.namespace",
        needs_semicolon: false,
        start_pattern: newPattern(
                match: variableBounds[/namespace/],
                tag_as: "keyword.other.namespace.definition storage.type.namespace.definition"
            ),
        head_includes: [
            :attributes_context,
            cpp_grammar[:scope_resolution_namespace_block].maybe(@spaces).then(
                    match: variable_name,
                    tag_as: "entity.name.namespace",
                ).maybe(@spaces).maybe(
                    newPattern(
                        match: /::/,
                        tag_as: "punctuation.separator.scope-resolution.namespace.block"
                    ).maybe(@spaces).then(
                        match: /inline/,
                        tag_as: "storage.modifier.inline"
                    )
                )
        ],
        )

#
# Preprocessor
#
    # not sure if this pattern is actually accurate (it was the one provided by atom/c.tmLanguage)
    preprocessor_name_no_bounds = /[a-zA-Z_$][\w$]*/
    preprocessor_function_name = preprocessor_name_no_bounds.lookAheadFor(maybe(@spaces).then(/\(/))
    cpp_grammar[:macro_argument] = newPattern(
        match: /##/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
        tag_as: "variable.other.macro.argument"
        )

#
# Lambdas
#
    array_of_invalid_function_names = @cpp_tokens.representationsThat(:canAppearBeforeLambdaCapture)
    non_variable_name = /#{array_of_invalid_function_names.map { |each| '\W'+each+'|^'+each } .join('|')}/
    cpp_grammar[:lambdas] = lambdas = PatternRange.new(
        start_pattern: newPattern(
                should_fully_match: [ "[]", "[=]", "[&]", "[x,y,x]", "[x, y, &z, w = 1 + 1]", "[ a = blah[1324], b, c ]" ],
                should_partial_match: [ "[]", "[=](", "[&]{", "[x,y,x]", "[x, y, &z, w = 1 + 1] (", "[ a = blah[1324], b, c ] {" ],
                should_not_partial_match: [ "delete[]", "thing[]", "thing []", "thing     []", "thing[0][0] = 0" ],
                match: lookBehindFor(/[^\s]|^/).lookBehindToAvoid(/[\w\]\)\[\*&>]/).or(lookBehindFor(non_variable_name)).maybe(@spaces).then(
                        match: /\[/.lookAheadToAvoid(/\[/),
                        tag_as: "punctuation.definition.capture.begin.lambda",
                    ).then(
                        match: /(?:.*\[.*?\].*?)*.*?/,
                        tag_as: "meta.lambda.capture",
                        # the zeroOrMoreOf() is for other []'s that are inside of the lambda capture
                        # this pattern is still imperfect: if someone had a string literal with ['s in it, it could fail
                        includes: [ :function_parameter_context ],
                    ).then(
                        match: /\]/,
                        tag_as: "punctuation.definition.capture.end.lambda",
                    )
            ),
        end_pattern: newPattern(
                match: lookBehindFor(/}/),
            ),
        includes: [
            # check for parameters first
            PatternRange.new(
                tag_as: 'meta.function.definition.parameters.lambda',
                start_pattern: newPattern(
                        match: /\(/,
                        tag_as:  "punctuation.definition.parameters.begin.lambda",
                    ),
                end_pattern: newPattern(
                        match: /\)/,
                        tag_as:  "punctuation.definition.parameters.end.lambda",
                    ),
                includes: [ :function_parameter_context ]
            ),
            # specifiers
            newPattern(
                match: variableBounds[ @cpp_tokens.that(:isLambdaSpecifier) ],
                tag_as: "storage.modifier.lambda.$match"
            ),
            # check for the -> syntax
            newPattern(
                match: /->/,
                tag_as: "punctuation.definition.lambda.return-type"
            ).maybe(
                match: /.+?/.lookAheadFor(/\{|$/),
                tag_as: "storage.type.return-type.lambda"
            ),
            # then find the body
            PatternRange.new(
                tag_as: "meta.function.definition.body.lambda",
                start_pattern: newPattern(
                        match: /\{/,
                        tag_as:  "punctuation.section.block.begin.bracket.curly.lambda",
                    ),
                end_pattern: newPattern(
                        match: /\}/,
                        tag_as:  "punctuation.section.block.end.bracket.curly.lambda",
                    ),
                includes: [ :root_context ]
            ),
        ]
        )

#
# Support
#
    # generally this section is for things that need a #include, (the support category)
    # it will be for things such as cout, cin, vector, string, map, etc
    cpp_grammar[:pthread_types] = pthread_types = newPattern(
        tag_as: "support.type.posix-reserved.pthread support.type.built-in.posix-reserved.pthread",
        match: variableBounds[ /pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t/ ],
        )
    cpp_grammar[:posix_reserved_types] = posix_reserved_types = newPattern(
        match: variableBounds[  /[a-zA-Z_]/.zeroOrMoreOf(@standard_character).then(/_t/)  ],
        tag_as: "support.type.posix-reserved support.type.built-in.posix-reserved"
        )
    cpp_grammar[:predefined_macros] = predefinedMacros()


#
# Classes, structs, unions, enums
#
    cpp_grammar[:enumerator_list] = newPattern(
        match: newPattern(
            match: variable_name,
            tag_as: "variable.other.enummember",
        ).maybe(@spaces).maybe(inline_attribute).maybe(@spaces)
        .maybe(
            newPattern(
                match: /\=/,
                tag_as: "keyword.operator.assignment",
            ).maybe(@spaces).then(
                match: /.+?/,
                includes: [ :evaluation_context ]
            ).maybe(@spaces)
        ).then(newPattern(
            match: /[,;]/.or(/\n/),
            includes: [
                :comma,
                :semicolon,
            ],
        ).or(lookAheadFor(/\}/)).or(lookAheadFor(/\/\//.or(/\/\*/)))),
        tag_as: "meta.enum.definition",
    )
    # see https://en.cppreference.com/w/cpp/language/enum
    # this range matches both the case with brackets and the case without brackets
    cpp_grammar[:enum_block] = generateBlockFinder(
            name: "enum",
            tag_as: "meta.block.enum",
            start_pattern: newPattern(
                    match: variableBounds[ /enum/ ],
                    tag_as: "storage.type.enum"
                ).maybe(
                    @spaces.then(
                        # see "Scoped enumerations" on  https://en.cppreference.com/w/cpp/language/enum
                        match: /class|struct/,
                        tag_as: "storage.type.enum.enum-key.$match",
                    )
                ).then(@spaces.or(inline_attribute).or(lookAheadFor(/{/))).maybe(@spaces).maybe(
                    match: variable_name,
                    tag_as: "entity.name.type.enum",
                ).maybe(
                    maybe(@spaces).then(
                        match: /:/,
                        tag_as: "colon punctuation.separator.type-specifier",
                    ).maybe(@spaces).maybe(
                        scope_resolution
                    ).maybe(@spaces).then(
                        match: variable_name,
                        tag_as: "storage.type.integral.$match",
                    )
            ),
            head_includes: [ :root_context ],
            body_includes: [ :enumerator_list, :comments_context, :comma, :semicolon ],
        )
    # the following are basically the equivlent of:
    #     @cpp_tokens.that(:isAccessSpecifier).or(/,/).or(/:/)
    # that ^ causes an error in the lookBehindFor() so it has to be manually spread
    can_come_before_a_inherited_class = @cpp_tokens.representationsThat(:isInheritanceSpecifier) + [ ',', ':', ]
    can_come_before_a_inherited_class_regex = /#{can_come_before_a_inherited_class.join('|')}/
    cpp_grammar[:inheritance_context] = [
        newPattern(
            match: /,/,
            tag_as: "comma punctuation.separator.delimiter.inheritance"
        ),
        newPattern(
            match: variableBounds[ @cpp_tokens.that(:isAccessSpecifier) ],
            tag_as: "storage.type.modifier.access.$match",
        ),
        newPattern(
            match: variableBounds[ /virtual/ ],
            tag_as: "storage.type.modifier.virtual",
        ),
        lookBehindFor(can_come_before_a_inherited_class_regex).maybe(@spaces).lookAheadToAvoid(@cpp_tokens.that(:isAccessSpecifier).or(/virtual/)).then(
            match: qualified_type.without_numbered_capture_groups,
            tag_as: "entity.name.type.inherited"
        )
    ]
    final_modifier = newPattern(
        match: /final/,
        tag_as: "storage.type.modifier.final",
    )
    generateClassOrStructBlockFinder = ->(name, tail_includes = [:root_context]) do
        return generateBlockFinder(
            tag_as: "meta.block.#{name}",
            name: name,
            start_pattern: newPattern(
                    should_fully_match: ["#{name} foo: bar", "#{name} foo: public baz"],
                    should_not_fully_match: ["#{name} foo {","#{name} foo{"],
                    should_partial_match: ["#{name} foo f;", "#{name} st s;"],
                    match: newPattern(
                        reference: "storage_type",
                        match: variableBounds[ /#{name}/ ],
                        tag_as: "storage.type.$match",
                    ).then(
                        @spaces.or(
                            inline_attribute
                        ).or(
                            lookAheadFor(/{/)
                        )
                    ).maybe(inline_attribute).maybe(@spaces).maybe(
                        match: variable_name,
                        tag_as: "entity.name.type.$reference(storage_type)",
                    ).maybe(
                        @spaces.then(final_modifier).maybe(@spaces)
                    ).maybe(
                        #
                        # inheritance
                        #
                        maybe(@spaces).then(
                            match: /:/,
                            tag_as: "colon punctuation.separator.inheritance"
                        # the following may seem redundant (removing it shouldn't change anything)
                        # this is because the follow are matched by what is inside of this Range
                        # However its preferable to match things here, in the Start (using a pattern), over matching it inside of the range
                        # this is because the start pattern typically fails safely (is limited to 1 line), while typically Ranges fail dangerously (can match the whole document)
                        ).zeroOrMoreOf(
                            match: maybe(@spaces).maybe(/,/).maybe(
                                @spaces
                            ).maybe(
                                @cpp_tokens.that(:isAccessSpecifier)
                            ).maybe(@spaces).oneOrMoreOf(
                                maybe(@spaces).maybe(/,/).maybe(
                                    @spaces
                                ).lookAheadToAvoid(
                                    @cpp_tokens.that(:isAccessSpecifier)
                                ).then(qualified_type.without_numbered_capture_groups)
                            ),
                            includes: [ :inheritance_context ]
                        )
                    ),
                ),
            head_includes: [
                :preprocessor_context,
                :inheritance_context,
                :template_call_range,
                :comments_context,
            ],
            body_includes: [ :function_pointer, :constructor_context, :root_context ],
            tail_includes: tail_includes
        )
    end
    cpp_grammar[:class_block] = generateClassOrStructBlockFinder["class"]
    cpp_grammar[:struct_block] = generateClassOrStructBlockFinder["struct"]
    cpp_grammar[:union_block] = generateClassOrStructBlockFinder["union"]
    # the following is a legacy pattern, I'm not sure if it is still accurate
    # I have no idea why it matches a double quote
    cpp_grammar[:extern_block] = generateBlockFinder(
        name: 'extern',
        tag_as: "meta.block.extern",
        start_pattern: newPattern(
                match: /\bextern/,
                tag_as: "storage.type.extern"
            ).lookAheadFor(/\s*\"/),
        head_includes: [ :root_context ],
        secondary_includes: [ :root_context ]
        )
    generateTypedefClassOrStructBlockFinder =-> (name) do
        return PatternRange.new(
            start_pattern: newPattern(
                match: variableBounds[/typedef/],
                tag_as: "keyword.other.typedef"
            ).maybe(@spaces).lookAheadFor(variableBounds[/#{name}/]),
            end_pattern: lookBehindFor(/;/),
            includes: [
                generateClassOrStructBlockFinder[name, [
                    ref_deref_definition_pattern.then(
                        match: variable_name,
                        tag_as: "entity.name.type.alias"
                    ),
                    /,/,
                ]]
            ]
        )
    end
    cpp_grammar[:typedef_class] = generateTypedefClassOrStructBlockFinder["class"]
    cpp_grammar[:typedef_struct] = generateTypedefClassOrStructBlockFinder["struct"]
    cpp_grammar[:typedef_union] = generateTypedefClassOrStructBlockFinder["union"]
#
# preprocessor directives
#
    # TODO, change all blocks/paraentheses so that they end and the end of a macro
    # TODO, find a good solution to dealing with if statments that cross in to/out of blocks
    cpp_grammar[:hacky_fix_for_stray_directive] = hacky_fix_for_stray_directive = newPattern(
            match: variableBounds[/#(?:endif|else|elif)/],
            tag_as: "keyword.control.directive.$match"
        )

#
# Misc Legacy
#
    cpp_grammar[:square_brackets] = {
            name: "meta.bracket.square.access",
            begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))?(\\[)(?!\\])",
            beginCaptures: {
                "1" => {
                    name: "variable.other.object"
                },
                "2" => {
                    name: "punctuation.definition.begin.bracket.square"
                }
            },
            end: "\\]",
            endCaptures: {
                "0" => {
                    name: "punctuation.definition.end.bracket.square"
                }
            },
            patterns: [
                {
                    include: "#function_call_context"
                }
            ]
        }
    cpp_grammar[:empty_square_brackets] = {
            name: "storage.modifier.array.bracket.square",
            match: /#{lookBehindToAvoid(/delete/)}\\[\\s*\\]/
        }
    cpp_grammar[:assembly] = newPattern(
            match: variableBounds[ /(asm|__asm__)/ ],
            tag_as: "storage.type.$match"
        )
    cpp_grammar[:misc_storage_modifiers_1] = {
            match: /\b(constexpr|export|mutable|typename|thread_local)\b/,
            name: "storage.modifier"
        }
    cpp_grammar[:misc_storage_modifiers_2] = {
            match: /\b(const|extern|register|restrict|static|volatile|inline)\b/,
            name: "storage.modifier"
        }
    #destructors accept no parameters
    cpp_grammar[:destructor] = newPattern(
        should_fully_match: ["~bar()", "foo::~foo()"],
        tag_as: "meta.function.destructor",
        match: lookBehindToAvoid(/[a-zA-Z0-9_]/).then(
            match: newPattern(
                    newPattern(match: identifier, reference: "class_name", dont_back_track?: true).maybe(@spaces).then(/::/).maybe(@spaces)
                    .then(/~/).backReference("class_name")
                ).or(
                    newPattern(/~/).then(match: identifier, dont_back_track?: true)
                ),
            tag_as: "entity.name.function.destructor entity.name.function.special.destructor"
        ).maybe(@spaces).then(
            match: /\(/,
            tag_as: "punctuation.definition.parameters.begin.destructor",
        ).maybe(@spaces).then(
            match: /\)/,
            tag_as: "punctuation.definition.parameters.end.destructor",
        )
    )
    cpp_grammar[:meta_preprocessor_macro] = {
            name: "meta.preprocessor.macro",
            begin: "(?x)\n^\\s* ((\\#)\\s*define) \\s+\t# define\n((?<id>#{preprocessor_name_no_bounds}))\t  # macro name\n(?:\n  (\\()\n\t(\n\t  \\s* \\g<id> \\s*\t\t # first argument\n\t  ((,) \\s* \\g<id> \\s*)*  # additional arguments\n\t  (?:\\.\\.\\.)?\t\t\t# varargs ellipsis?\n\t)\n  (\\))\n)?",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.define"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                },
                "3" => {
                    name: "entity.name.function.preprocessor"
                },
                "5" => {
                    name: "punctuation.definition.parameters.begin"
                },
                "6" => {
                    name: "variable.parameter.preprocessor"
                },
                "8" => {
                    name: "punctuation.separator.parameters"
                },
                "9" => {
                    name: "punctuation.definition.parameters.end"
                }
            },
            end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    include: "#preprocessor_rule_define_line_context"
                }
            ]
        }
    cpp_grammar[:meta_preprocessor_diagnostic] = {
            name: "meta.preprocessor.diagnostic",
            begin: "^\\s*((#)\\s*(error|warning))\\b\\s*",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.diagnostic.$3"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    begin: "\"",
                    beginCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.begin"
                        }
                    },
                    end: "\"|(?<!\\\\)(?=\\s*\\n)",
                    endCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.end"
                        }
                    },
                    name: "string.quoted.double",
                    patterns: [
                        {
                            include: "#line_continuation_character"
                        }
                    ]
                },
                {
                    begin: "'",
                    beginCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.begin"
                        }
                    },
                    end: "'|(?<!\\\\)(?=\\s*\\n)",
                    endCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.end"
                        }
                    },
                    name: "string.quoted.single",
                    patterns: [
                        {
                            include: "#line_continuation_character"
                        }
                    ]
                },
                {
                    begin: "[^'\"]",
                    end: "(?<!\\\\)(?=\\s*\\n)",
                    name: "string.unquoted.single",
                    patterns: [
                        {
                            include: "#line_continuation_character"
                        },
                        {
                            include: "#comments_context"
                        }
                    ]
                }
            ]
        }
    cpp_grammar[:meta_preprocessor_include] = {
            name: "meta.preprocessor.include",
            begin: "^\\s*((#)\\s*(include(?:_next)?|import))\\b\\s*",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.$3"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    include: "#line_continuation_character"
                },
                {
                    begin: "\"",
                    beginCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.begin"
                        }
                    },
                    end: "\"",
                    endCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.end"
                        }
                    },
                    name: "string.quoted.double.include"
                },
                {
                    begin: "<",
                    beginCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.begin"
                        }
                    },
                    end: ">",
                    endCaptures: {
                        "0" => {
                            name: "punctuation.definition.string.end"
                        }
                    },
                    name: "string.quoted.other.lt-gt.include"
                }
            ]
        }
    cpp_grammar[:meta_preprocessor_line] = {
            name: "meta.preprocessor",
            begin: "^\\s*((#)\\s*line)\\b",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.line"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    include: "#string_context_c"
                },
                {
                    include: "#number_literal"
                },
                {
                    include: "#line_continuation_character"
                }
            ]
        }
    cpp_grammar[:meta_preprocessor_undef] = {
            name: "meta.preprocessor",
            begin: "^\\s*(?:((#)\\s*undef))\\b",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.undef"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    match: preprocessor_name_no_bounds,
                    name: "entity.name.function.preprocessor"
                },
                {
                    include: "#line_continuation_character"
                }
            ]
        }
    cpp_grammar[:meta_preprocessor_pragma] = {
            name: "meta.preprocessor.pragma",
            begin: "^\\s*(?:((#)\\s*pragma))\\b",
            beginCaptures: {
                "1" => {
                    name: "keyword.control.directive.pragma"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
            patterns: [
                {
                    include: "#string_context_c"
                },
                {
                    match: "[a-zA-Z_$][\\w\\-$]*",
                    name: "entity.other.attribute-name.pragma.preprocessor"
                },
                {
                    include: "#number_literal"
                },
                {
                    include: "#line_continuation_character"
                }
            ]
        }
    cpp_grammar[:constructor_context] = [
            {
                begin: "(?x)\n(?:^\\s*)  # beginning of line\n((?!while|for|do|if|else|switch|catch)[A-Za-z_][A-Za-z0-9_:]*) # actual name\n\\s*(\\()  # opening bracket",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function.constructor"
                    },
                    "2" => {
                        name: "punctuation.definition.parameters.begin.constructor"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.parameters.end.constructor"
                    }
                },
                name: "meta.function.constructor",
                patterns: [
                    {
                        include: "#function_parameter_context"
                    },
                ]
            },
            {
                begin: "(?x)\n(:)\n(\n  (?=\n    \\s*[A-Za-z_][A-Za-z0-9_:]* # actual name\n    \\s* (\\() # opening bracket\n  )\n)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.definition.initializer-list.parameters"
                    }
                },
                end: "(?=\\{)",
                name: "meta.function.constructor.initializer-list",
                patterns: [
                    {
                        include: "#root_context"
                    }
                ]
            }
        ]
    cpp_grammar[:string_context] = [
            PatternRange.new(
                tag_as: "string.quoted.double",
                start_pattern: newPattern(
                    tag_as: "punctuation.definition.string.begin",
                    match: maybe(match: /u|u8|U|L/, tag_as: "meta.encoding").then(/"/),
                ),
                end_pattern: newPattern(
                    tag_as: "punctuation.definition.string.end",
                    match: /"/,
                ),
                includes: [
                    # universal characters \u00AF, \U0001234F
                    newPattern(
                        match: universal_character,
                        tag_as: "constant.character.escape",
                    ),
                    # normal escapes \r, \n, \t
                    newPattern(
                        match: /\\['"?\\abfnrtv]/,
                        tag_as: "constant.character.escape",
                    ),
                    # octal escapes \017
                    newPattern(
                        match: /\\/.then(
                            match: /[0-7]/,
                            at_least: 1.times,
                            at_most: 3.times,
                        ),
                        tag_as: "constant.character.escape",
                    ),
                    # hex escapes
                    newPattern(
                        match: /\\x/.then(
                            match: /[0-9a-fA-F]/,
                            how_many_times?: 2.times,
                        ),
                        tag_as: "constant.character.escape",
                    ),
                    :string_escapes_context_c
                ]
            ),
            PatternRange.new(
                tag_as: "string.quoted.single",
                start_pattern: newPattern(
                    tag_as: "punctuation.definition.string.begin",
                    match: lookBehindToAvoid(/[0-9A-Fa-f]/).maybe(match: /u|u8|U|L/, tag_as: "meta.encoding")
                        .then(/'/),
                ),
                end_pattern: newPattern(
                    tag_as: "punctuation.definition.string.end",
                    match: /'/,
                ),
                includes: [
                    :string_escapes_context_c,
                    :line_continuation_character,
                ]
            ),
            {
                begin: "(u|u8|U|L)?R\"(?:([^ ()\\\\\\t]{0,16})|([^ ()\\\\\\t]*))\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    },
                    "1" => {
                        name: "meta.encoding"
                    },
                    "3" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                end: "\\)\\2(\\3)\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    },
                    "1" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                name: "string.quoted.double.raw"
            }
        ]
    cpp_grammar[:block] = {
            begin: "{",
            beginCaptures: {
                "0" => {
                    name: "punctuation.section.block.begin.bracket.curly"
                }
            },
            end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
            endCaptures: {
                "0" => {
                    name: "punctuation.section.block.end.bracket.curly"
                }
            },
            name: "meta.block",
            patterns: [
                {
                    include: "#block_context"
                }
            ]
        }
    cpp_grammar[:block_context] = [
        :preprocessor_rule_enabled_block,
        :preprocessor_rule_disabled_block,
        :preprocessor_rule_conditional_block,
        :method_access,
        :member_access,
        :type_casting_operators,
        :function_call,
        {
            name: "meta.initialization",
            begin: "(?x)\n(?:\n  (?:\n\t(?=\\s)(?<!else|new|return)\n\t(?<=\\w) \\s+(and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)  # or word + space before name\n  )\n)\n(\n  (?:[A-Za-z_][A-Za-z0-9_]*+ | :: )++   # actual name\n  |\n  (?:(?<=operator) (?:[-*&<>=+!]+ | \\(\\) | \\[\\]))\n)\n\\s*(\\() # opening bracket",
            beginCaptures: {
                "1" => {
                    name: "variable.other"
                },
                "2" => {
                    name: "punctuation.section.parens.begin.bracket.round.initialization"
                }
            },
            end: "\\)",
            endCaptures: {
                "0" => {
                    name: "punctuation.section.parens.end.bracket.round.initialization"
                }
            },
            patterns: [
                {
                    include: "#function_call_context"
                }
            ]
        },
        {
            begin: "{",
            beginCaptures: {
                "0" => {
                    name: "punctuation.section.block.begin.bracket.curly"
                }
            },
            end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
            endCaptures: {
                "0" => {
                    name: "punctuation.section.block.end.bracket.curly"
                }
            },
            patterns: [
                {
                    include: "#block_context"
                }
            ]
        },
        :parentheses_block,
        :root_context
        ]
    cpp_grammar[:comments_context] = {
        patterns: [
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.block"
                    }
                },
                match: "^/\\* =(\\s*.*?)\\s*= \\*/$\\n?",
                name: "comment.block"
            },
            {
                begin: "/\\*",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.begin"
                    }
                },
                end: "\\*/",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.end"
                    }
                },
                name: "comment.block"
            },
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.line"
                    }
                },
                match: "^// =(\\s*.*?)\\s*=\\s*$\\n?",
                name: "comment.line.banner"
            },
            {
                begin: "(^[ \\t]+)?(?=//)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.whitespace.comment.leading"
                    }
                },
                end: "(?!\\G)",
                patterns: [
                    {
                        begin: "//",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.definition.comment"
                            }
                        },
                        end: "(?=\\n)",
                        name: "comment.line.double-slash",
                        patterns: [
                            {
                                include: "#line_continuation_character"
                            }
                        ]
                    }
                ]
            }
        ]
        }
    cpp_grammar[:disabled] = {
        begin: "^\\s*#\\s*if(n?def)?\\b.*$",
        end: "^\\s*#\\s*endif\\b",
        patterns: [
            {
                include: "#disabled"
            },
            {
                include: "#pragma_mark"
            }
        ]
        }
    cpp_grammar[:line_continuation_character] = {
            match: "(\\\\)\\n",
            captures: {
                "1" => {
                    name: "constant.character.escape.line-continuation"
                }
            }
        }
    cpp_grammar[:parentheses] = {
        name: "meta.parens",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "#root_context"
            }
        ]
        }
    cpp_grammar[:parentheses_block] = {
        name: "meta.parens.block",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "#block_context"
            },
            {
                match: lookBehindToAvoid(/:/).then(/:/).lookAheadToAvoid(/:/),
                name: "colon punctuation.separator.range-based"
            }
        ]
        }
    cpp_grammar[:pragma_mark] = {
        captures: {
            "1" => {
                name: "meta.preprocessor.pragma"
            },
            "2" => {
                name: "keyword.control.directive.pragma.pragma-mark"
            },
            "3" => {
                name: "punctuation.definition.directive"
            },
            "4" => {
                name: "entity.name.tag.pragma-mark"
            }
        },
        match: "^\\s*(((#)\\s*pragma\\s+mark)\\s+(.*))",
        name: "meta.section"
        }
    cpp_grammar[:string_context_c] = [
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escapes_context_c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: lookBehindToAvoid(/[\da-fA-F]/).then(/'/),
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escapes_context_c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            }
        ]
    cpp_grammar[:string_escapes_context_c] = [
            {
                match: "(?x)\\\\ (\n\\\\\t\t\t |\n[abefnprtv'\"?]   |\n[0-3]\\d{,2}\t |\n[4-7]\\d?\t\t|\nx[a-fA-F0-9]{,2} |\nu[a-fA-F0-9]{,4} |\nU[a-fA-F0-9]{,8} )",
                name: "constant.character.escape"
            },
            {
                match: "\\\\.",
                name: "invalid.illegal.unknown-escape"
            },
            {
                match: "(?x) %\n(\\d+\\$)?\t\t\t\t\t\t   # field (argument #)\n[#0\\- +']*\t\t\t\t\t\t  # flags\n[,;:_]?\t\t\t\t\t\t\t  # separator character (AltiVec)\n((-?\\d+)|\\*(-?\\d+\\$)?)?\t\t  # minimum field width\n(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?\t# precision\n(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n[diouxXDOUeEfFgGaACcSspn%]\t\t   # conversion type",
                name: "constant.other.placeholder"
            },
            # I don't think these are actual escapes, and they incorrectly mark valid strings
            # It might be related to printf and format from C (which is low priority for C++)
            # {
            #     match: "(%)(?!\"\\s*(PRI|SCN))",
            #     captures: {
            #         "1" => {
            #             name: "constant.other.placeholder"
            #         }
            #     }
            # }
        ]
    cpp_grammar[:vararg_ellipses] = {
        match: "(?<!\\.)\\.\\.\\.(?!\\.)",
        name: "punctuation.vararg-ellipses"
        }
    cpp_grammar[:preprocessor_rule_conditional] = {
            begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#preprocessor_rule_enabled_elif"
                },
                {
                    include: "#preprocessor_rule_enabled_else"
                },
                {
                    include: "#preprocessor_rule_disabled_elif"
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#root_context"
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_conditional_block] = {
            begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#preprocessor_rule_enabled_elif_block"
                },
                {
                    include: "#preprocessor_rule_enabled_else_block"
                },
                {
                    include: "#preprocessor_rule_disabled_elif"
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#block_context"
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_conditional_line_context] = [
            {
                match: "(?:\\bdefined\\b\\s*$)|(?:\\bdefined\\b(?=\\s*\\(*\\s*(?:(?!defined\\b)[a-zA-Z_$][\\w$]*\\b)\\s*\\)*\\s*(?:\\n|//|/\\*|\\?|\\:|&&|\\|\\||\\\\\\s*\\n)))",
                name: "keyword.control.directive.conditional"
            },
            {
                match: "\\bdefined\\b",
                name: "invalid.illegal.macro-name"
            },
            :comments_context,
            :string_context_c,
            :number_literal,
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor_rule_conditional_line_context"
                    }
                ]
            },
            :operators,
            :language_constants,
            {
                match: preprocessor_name_no_bounds,
                name: "entity.name.function.preprocessor"
            },
            :line_continuation_character,
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)|(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor_rule_conditional_line_context"
                    }
                ]
            }
        ]
    cpp_grammar[:preprocessor_rule_disabled] = {
            begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#comments_context"
                },
                {
                    include: "#preprocessor_rule_enabled_elif"
                },
                {
                    include: "#preprocessor_rule_enabled_else"
                },
                {
                    include: "#preprocessor_rule_disabled_elif"
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                    patterns: [
                        {
                            begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                            end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                            name: "meta.preprocessor",
                            patterns: [
                                {
                                    include: "#preprocessor_rule_conditional_line_context"
                                }
                            ]
                        },
                        {
                            include: "#root_context"
                        }
                    ]
                },
                {
                    begin: "\\n",
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    "contentName" => "comment.block.preprocessor.if-branch",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_disabled_block] = {
            begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#comments_context"
                },
                {
                    include: "#preprocessor_rule_enabled_elif_block"
                },
                {
                    include: "#preprocessor_rule_enabled_else_block"
                },
                {
                    include: "#preprocessor_rule_disabled_elif"
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                    patterns: [
                        {
                            begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                            end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                            name: "meta.preprocessor",
                            patterns: [
                                {
                                    include: "#preprocessor_rule_conditional_line_context"
                                }
                            ]
                        },
                        {
                            include: "#block_context"
                        }
                    ]
                },
                {
                    begin: "\\n",
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    "contentName" => "comment.block.preprocessor.if-branch.in-block",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_disabled_elif] = {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor_rule_conditional_line_context"
                    }
                ]
            },
            {
                include: "#comments_context"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                "contentName" => "comment.block.preprocessor.elif-branch",
                patterns: [
                    {
                        include: "#disabled"
                    },
                    {
                        include: "#pragma_mark"
                    }
                ]
            }
        ]
        }
    cpp_grammar[:preprocessor_rule_enabled] = {
            begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                },
                "3" => {
                    name: "constant.numeric.preprocessor"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#comments_context"
                },
                {
                    begin: "^\\s*((#)\\s*else\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*endif\\b))",
                    "contentName" => "comment.block.preprocessor.else-branch",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    "contentName" => "comment.block.preprocessor.if-branch",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                },
                {
                    begin: "\\n",
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    patterns: [
                        {
                            include: "#root_context"
                        }
                    ]
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_enabled_block] = {
            begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
            beginCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            end: "^\\s*((#)\\s*endif\\b)",
            endCaptures: {
                "0" => {
                    name: "meta.preprocessor"
                },
                "1" => {
                    name: "keyword.control.directive.conditional"
                },
                "2" => {
                    name: "punctuation.definition.directive"
                }
            },
            patterns: [
                {
                    begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                    end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                    name: "meta.preprocessor",
                    patterns: [
                        {
                            include: "#preprocessor_rule_conditional_line_context"
                        }
                    ]
                },
                {
                    include: "#comments_context"
                },
                {
                    begin: "^\\s*((#)\\s*else\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*endif\\b))",
                    "contentName" => "comment.block.preprocessor.else-branch.in-block",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                },
                {
                    begin: "^\\s*((#)\\s*elif\\b)",
                    beginCaptures: {
                        "0" => {
                            name: "meta.preprocessor"
                        },
                        "1" => {
                            name: "keyword.control.directive.conditional"
                        },
                        "2" => {
                            name: "punctuation.definition.directive"
                        }
                    },
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    "contentName" => "comment.block.preprocessor.if-branch.in-block",
                    patterns: [
                        {
                            include: "#disabled"
                        },
                        {
                            include: "#pragma_mark"
                        }
                    ]
                },
                {
                    begin: "\\n",
                    end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                    patterns: [
                        {
                            include: "#block_context"
                        }
                    ]
                }
            ]

        }
    cpp_grammar[:preprocessor_rule_enabled_elif] = {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor_rule_conditional_line_context"
                    }
                ]
            },
            {
                include: "#comments_context"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma_mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma_mark"
                            }
                        ]
                    },
                    {
                        include: "#root_context"
                    }
                ]
            }
        ]
        }
    cpp_grammar[:preprocessor_rule_enabled_elif_block] = {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor_rule_conditional_line_context"
                    }
                ]
            },
            {
                include: "#comments_context"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma_mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma_mark"
                            }
                        ]
                    },
                    {
                        include: "#block_context"
                    }
                ]
            }
        ]
        }
    cpp_grammar[:preprocessor_rule_enabled_else] = {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "#root_context"
            }
        ]
        }
    cpp_grammar[:preprocessor_rule_enabled_else_block] = {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "#block_context"
            }
        ]
        }
    cpp_grammar[:preprocessor_rule_define_line_context] = [
            :vararg_ellipses,
            {
                match: /##?/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
                name: "variable.other.macro.argument"
            },
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                name: "meta.block",
                patterns: [
                    {
                        include: "#preprocessor_rule_define_line_blocks_context"
                    }
                ]
            },
            {
                match: "\\(",
                name: "punctuation.section.parens.begin.bracket.round"
            },
            {
                match: "\\)",
                name: "punctuation.section.parens.end.bracket.round"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\s*\\()\n(?=\n  (?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name\n  |\n  (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(\n)",
                end: "(?<=\\))(?!\\w)|(?<!\\\\)(?=\\s*\\n)",
                name: "meta.function",
                patterns: [
                    {
                        include: "#preprocessor_rule_define_line_functions_context"
                    }
                ]
            },
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escapes_context_c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "'",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escapes_context_c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            :method_access,
            :member_access,
            :root_context
        ]
    cpp_grammar[:preprocessor_rule_define_line_blocks_context] = [
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor_rule_define_line_blocks_context"
                    },
                    {
                        include: "#preprocessor_rule_define_line_context"
                    }
                ]
            },
            {
                include: "#preprocessor_rule_define_line_context"
            }
        ]
    legacy_memory_new_call = {
            begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:new)\\s*(#{maybe(template_call.without_numbered_capture_groups)}) # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
            beginCaptures: {
                "1" => {
                    name: "keyword.operator.wordlike memory keyword.operator.new"
                },
                "2" => {
                    patterns: [
                        {
                            include: "#template_call_innards"
                        }
                    ]
                },
                "3" => {
                    name: "punctuation.section.arguments.begin.bracket.round"
                },
            },
            end: "\\)",
            endCaptures: {
                "0" => {
                    name: "punctuation.section.arguments.end.bracket.round"
                }
            },
            patterns: [
                {
                    include: "#function_call_context"
                }
            ]
        }
    cpp_grammar[:preprocessor_rule_define_line_functions_context] = [
            :comments_context,
            :storage_types,
            :vararg_ellipses,
            :method_access,
            :member_access,
            :operators,
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function"
                    },
                    "2" => {
                        name: "punctuation.section.arguments.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.arguments.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor_rule_define_line_functions_context"
                    }
                ]
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor_rule_define_line_functions_context"
                    }
                ]
            },
            :preprocessor_rule_define_line_context
        ]
    cpp_grammar[:function_call_context] = [
            :struct_declare,
            :string_context,
            :functional_specifiers_pre_parameters,
            :qualifiers_and_specifiers_post_parameters,
            :storage_specifiers,
            :access_control_keywords,
            :exception_keywords,
            :static_assert,
            :other_keywords,
            :memory_operators,
            :the_this_keyword,
            :language_constants,
            :misc_storage_modifiers_1,
            :lambdas,
            :preprocessor_context,
            :comments_context,
            :misc_storage_modifiers_2,
            :number_literal,
            :string_context_c,
            :meta_preprocessor_macro,
            :meta_preprocessor_diagnostic,
            :meta_preprocessor_include,
            :pragma_mark,
            :meta_preprocessor_line,
            :meta_preprocessor_undef,
            :meta_preprocessor_pragma,
            :predefined_macros,
            :operators,
            :attributes_context, # this is here because it needs to be lower than :operators. TODO: once all the contexts are cleaned up, this should be put in a better spot
            :parentheses,
            :type_casting_operators,
            :function_call,
            :scope_resolution_inner_generated,
            :storage_types,
            :line_continuation_character,
            :square_brackets,
            :empty_square_brackets,
            :semicolon,
            :comma,
        ]

# Save
@syntax_location = saveGrammar(cpp_grammar)
# TODO, upgrade the code so this is not necessary
# for exporting to C
@cpp_grammar = cpp_grammar